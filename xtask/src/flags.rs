use std::{fmt::Display, str::FromStr};

xflags::xflags! {
    src "./src/flags.rs"

    /// Run a custom build command
    cmd xtask {
        cmd codegen {
            /// Which specific code should be generated
            optional codegen_type: CodegenType
            /// Checks if the generated code type is up to date
            optional --check
        }

        /// Packages a compiler component
        cmd package {

            // Packages the lsp server and client
            cmd lsp {
                /// Only package the language server
                optional --server

                /// Only package the language client extension (VSCode only)
                optional --client
            }
        }
    }
}

// generated start
// The following code is generated by `xflags` macro.
// Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
#[derive(Debug)]
pub struct Xtask {
    pub subcommand: XtaskCmd,
}

#[derive(Debug)]
pub enum XtaskCmd {
    Codegen(Codegen),
    Package(Package),
}

#[derive(Debug)]
pub struct Codegen {
    pub codegen_type: Option<CodegenType>,

    pub check: bool,
}

#[derive(Debug)]
pub struct Package {
    pub subcommand: PackageCmd,
}

#[derive(Debug)]
pub enum PackageCmd {
    Lsp(Lsp),
}

#[derive(Debug)]
pub struct Lsp {
    pub server: bool,
    pub client: bool,
}

impl Xtask {
    #[allow(dead_code)]
    pub fn from_env_or_exit() -> Self {
        Self::from_env_or_exit_()
    }

    #[allow(dead_code)]
    pub fn from_env() -> xflags::Result<Self> {
        Self::from_env_()
    }

    #[allow(dead_code)]
    pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
        Self::from_vec_(args)
    }
}
// generated end

#[derive(Debug, Default)]
pub enum CodegenType {
    #[default]
    All,
    Grammar,
    TuringBytecode,
}

impl FromStr for CodegenType {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "grammar" => Ok(Self::Grammar),
            "turing-bytecode" => Ok(Self::TuringBytecode),
            _ => Err("Invalid type".to_owned()),
        }
    }
}

impl Display for CodegenType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::All => write!(f, "all"),
            Self::Grammar => write!(f, "grammar"),
            Self::TuringBytecode => write!(f, "turing-bytecode"),
        }
    }
}

impl Lsp {
    pub(crate) fn server(&self) -> Option<()> {
        if self.client && !self.server {
            return None;
        }

        Some(())
    }

    pub(crate) fn client(&self) -> Option<()> {
        if self.server && !self.client {
            return None;
        }

        Some(())
    }
}
