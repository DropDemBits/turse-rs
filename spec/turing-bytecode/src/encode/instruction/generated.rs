//! Generated by `xtask codegen turing-bytecode`, do not edit by hand

use crate::encode::instruction::{Instruction, InstructionEncoder, InstructionRef};
use crate::instruction::*;
use byteorder::{WriteBytesExt, LE};
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
#[doc = "An operand for an encoded instruction."]
pub enum Operand {
    Int1(Int1),
    Int2(Int2),
    Int4(Int4),
    Nat2(Nat2),
    Nat4(Nat4),
    Real8(Real8),
    Offset(Offset),
    RelocatableOffset(RelocatableOffset),
    Addrint(Addrint),
    AbortReason(AbortReason),
    PutKind(PutKind),
    GetKind(GetKind),
    StdStreamKind(StdStreamKind),
    StreamKind(StreamKind),
    CheckKind(CheckKind),
}
impl Operand {
    #[doc = "Size of the operand, in bytes."]
    pub fn size(&self) -> usize {
        match self {
            Self::Int1(_) => 4usize,
            Self::Int2(_) => 4usize,
            Self::Int4(_) => 4usize,
            Self::Nat2(_) => 4usize,
            Self::Nat4(_) => 4usize,
            Self::Real8(_) => 8usize,
            Self::Offset(_) => 4usize,
            Self::RelocatableOffset(_) => 8usize,
            Self::Addrint(_) => 4usize,
            Self::AbortReason(_) => 4usize,
            Self::PutKind(_) => 4usize,
            Self::GetKind(_) => 16usize,
            Self::StdStreamKind(_) => 4usize,
            Self::StreamKind(_) => 4usize,
            Self::CheckKind(_) => 4usize,
        }
    }
    #[doc = "Encodes the operand into the equivalent byte representation."]
    pub fn encode(&self, out: &mut impl std::io::Write) -> std::io::Result<()> {
        match self {
            Self::Int1(value) => {
                out.write_i8(*value)?;
                out.write_u8(0)?;
                out.write_u8(0)?;
                out.write_u8(0)?;
                Ok(())
            }
            Self::Int2(value) => {
                out.write_i16::<LE>(*value)?;
                out.write_u8(0)?;
                out.write_u8(0)?;
                Ok(())
            }
            Self::Int4(value) => out.write_i32::<LE>(*value),
            Self::Nat2(value) => {
                out.write_u16::<LE>(*value)?;
                out.write_u8(0)?;
                out.write_u8(0)?;
                Ok(())
            }
            Self::Nat4(value) => out.write_u32::<LE>(*value),
            Self::Real8(value) => out.write_f64::<LE>(*value),
            Self::Offset(value) => out.write_u32::<LE>(*value),
            Self::RelocatableOffset(value) => value.encode(out),
            Self::Addrint(value) => out.write_u32::<LE>(*value),
            Self::AbortReason(value) => value.encode(out),
            Self::PutKind(value) => value.encode(out),
            Self::GetKind(value) => value.encode(out),
            Self::StdStreamKind(value) => value.encode(out),
            Self::StreamKind(value) => value.encode(out),
            Self::CheckKind(value) => value.encode(out),
        }
    }
}
pub(crate) const MAX_OPERANDS: usize = 4usize;
impl QuitException {
    #[doc = "Encodes the type into the equivalent byte representation."]
    pub fn encode(&self, out: &mut impl std::io::Write) -> std::io::Result<()> {
        out.write_u32::<LE>(*self as u32)
    }
}
impl RelocatableOffset {
    #[doc = "Encodes the type into the equivalent byte representation."]
    pub fn encode(&self, out: &mut impl std::io::Write) -> std::io::Result<()> {
        out.write_u32::<LE>(self.link)?;
        out.write_u32::<LE>(self.offset)?;
        Ok(())
    }
}
impl AbortReason {
    #[doc = "Encodes the type into the equivalent byte representation."]
    pub fn encode(&self, out: &mut impl std::io::Write) -> std::io::Result<()> {
        out.write_u32::<LE>(*self as u32)
    }
}
impl PutKind {
    #[doc = "Encodes the type into the equivalent byte representation."]
    pub fn encode(&self, out: &mut impl std::io::Write) -> std::io::Result<()> {
        out.write_u32::<LE>(*self as u32)
    }
}
impl GetKind {
    #[doc = "Encodes the type into the equivalent byte representation."]
    pub fn encode(&self, out: &mut impl std::io::Write) -> std::io::Result<()> {
        match self {
            Self::Boolean { size } => {
                out.write_u32::<LE>(0u32)?;
                out.write_u32::<LE>(*size)?;
            }
            Self::Char { size } => {
                out.write_u32::<LE>(1u32)?;
                out.write_u32::<LE>(*size)?;
            }
            Self::CharRange { size, min, max } => {
                out.write_u32::<LE>(2u32)?;
                out.write_u32::<LE>(*size)?;
                out.write_u32::<LE>(*min)?;
                out.write_u32::<LE>(*max)?;
            }
            Self::CharN { size } => {
                out.write_u32::<LE>(3u32)?;
                out.write_u32::<LE>(*size)?;
            }
            Self::Enum { size } => {
                out.write_u32::<LE>(4u32)?;
                out.write_u32::<LE>(*size)?;
            }
            Self::EnumRange { size, min, max } => {
                out.write_u32::<LE>(5u32)?;
                out.write_u32::<LE>(*size)?;
                out.write_u32::<LE>(*min)?;
                out.write_u32::<LE>(*max)?;
            }
            Self::Int { size } => {
                out.write_u32::<LE>(6u32)?;
                out.write_u32::<LE>(*size)?;
            }
            Self::IntRange { size, min, max } => {
                out.write_u32::<LE>(7u32)?;
                out.write_u32::<LE>(*size)?;
                out.write_i32::<LE>(*min)?;
                out.write_i32::<LE>(*max)?;
            }
            Self::Nat { size } => {
                out.write_u32::<LE>(8u32)?;
                out.write_u32::<LE>(*size)?;
            }
            Self::Real { size } => {
                out.write_u32::<LE>(9u32)?;
                out.write_u32::<LE>(*size)?;
            }
            Self::StringExact { size } => {
                out.write_u32::<LE>(10u32)?;
                out.write_u32::<LE>(*size)?;
            }
            Self::StringLine { size } => {
                out.write_u32::<LE>(11u32)?;
                out.write_u32::<LE>(*size)?;
            }
            Self::StringToken { size } => {
                out.write_u32::<LE>(12u32)?;
                out.write_u32::<LE>(*size)?;
            }
            Self::Skip => {
                out.write_u32::<LE>(13u32)?;
            }
        }
        Ok(())
    }
}
impl StdStreamKind {
    #[doc = "Encodes the type into the equivalent byte representation."]
    pub fn encode(&self, out: &mut impl std::io::Write) -> std::io::Result<()> {
        out.write_u32::<LE>(*self as u32)
    }
}
impl StreamKind {
    #[doc = "Encodes the type into the equivalent byte representation."]
    pub fn encode(&self, out: &mut impl std::io::Write) -> std::io::Result<()> {
        out.write_u32::<LE>(*self as u32)
    }
}
impl CheckKind {
    #[doc = "Encodes the type into the equivalent byte representation."]
    pub fn encode(&self, out: &mut impl std::io::Write) -> std::io::Result<()> {
        out.write_u32::<LE>(*self as u32)
    }
}
impl Location {
    #[doc = "Encodes the type into the equivalent byte representation."]
    pub fn encode(&self, out: &mut impl std::io::Write) -> std::io::Result<()> {
        out.write_u16::<LE>(self.file_no)?;
        out.write_u16::<LE>(self.line_no)?;
        Ok(())
    }
}
impl ForDescriptor {
    #[doc = "Encodes the type into the equivalent byte representation."]
    pub fn encode(&self, out: &mut impl std::io::Write) -> std::io::Result<()> {
        out.write_i32::<LE>(self.counter)?;
        out.write_i32::<LE>(self.end)?;
        out.write_i32::<LE>(self.step)?;
        out.write_u32::<LE>(self.save_sp)?;
        Ok(())
    }
}
impl InstructionEncoder {
    #[doc = "Encode a [**ABORT**](Opcode::ABORT) instruction.\n\n## Operands\n\n- abort_kind: What is the reason for aborting\n"]
    pub fn abort(&mut self, abort_kind: AbortReason) -> InstructionRef {
        self.add(Instruction::new(Opcode::ABORT).with_operand(Operand::AbortReason(abort_kind)))
    }
    #[doc = "Encode a [**ABORTCOND**](Opcode::ABORTCOND) instruction.\n\n## Operands\n\n- abort_kind: What is the reason for aborting\n"]
    pub fn abortcond(&mut self, abort_kind: AbortReason) -> InstructionRef {
        self.add(Instruction::new(Opcode::ABORTCOND).with_operand(Operand::AbortReason(abort_kind)))
    }
    #[doc = "Encode a [**ADDINT**](Opcode::ADDINT) instruction."]
    pub fn addint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ADDINT)) }
    #[doc = "Encode a [**ADDINTNAT**](Opcode::ADDINTNAT) instruction."]
    pub fn addintnat(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ADDINTNAT)) }
    #[doc = "Encode a [**ADDNAT**](Opcode::ADDNAT) instruction."]
    pub fn addnat(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ADDNAT)) }
    #[doc = "Encode a [**ADDNATINT**](Opcode::ADDNATINT) instruction."]
    pub fn addnatint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ADDNATINT)) }
    #[doc = "Encode a [**ADDREAL**](Opcode::ADDREAL) instruction."]
    pub fn addreal(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ADDREAL)) }
    #[doc = "Encode a [**ADDSET**](Opcode::ADDSET) instruction.\n\n## Operands\n\n- set_length: Length of the set, in bytes.\n"]
    pub fn addset(&mut self, set_length: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::ADDSET).with_operand(Operand::Nat4(set_length)))
    }
    #[doc = "Encode a [**AND**](Opcode::AND) instruction."]
    pub fn and(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::AND)) }
    #[doc = "Encode a [**ASNADDR**](Opcode::ASNADDR) instruction."]
    pub fn asnaddr(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ASNADDR)) }
    #[doc = "Encode a [**ASNADDRINV**](Opcode::ASNADDRINV) instruction."]
    pub fn asnaddrinv(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::ASNADDRINV))
    }
    #[doc = "Encode a [**ASNINT**](Opcode::ASNINT) instruction."]
    pub fn asnint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ASNINT)) }
    #[doc = "Encode a [**ASNINTINV**](Opcode::ASNINTINV) instruction."]
    pub fn asnintinv(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ASNINTINV)) }
    #[doc = "Encode a [**ASNINT1**](Opcode::ASNINT1) instruction."]
    pub fn asnint1(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ASNINT1)) }
    #[doc = "Encode a [**ASNINT1INV**](Opcode::ASNINT1INV) instruction."]
    pub fn asnint1inv(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::ASNINT1INV))
    }
    #[doc = "Encode a [**ASNINT2**](Opcode::ASNINT2) instruction."]
    pub fn asnint2(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ASNINT2)) }
    #[doc = "Encode a [**ASNINT2INV**](Opcode::ASNINT2INV) instruction."]
    pub fn asnint2inv(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::ASNINT2INV))
    }
    #[doc = "Encode a [**ASNINT4**](Opcode::ASNINT4) instruction."]
    pub fn asnint4(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ASNINT4)) }
    #[doc = "Encode a [**ASNINT4INV**](Opcode::ASNINT4INV) instruction."]
    pub fn asnint4inv(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::ASNINT4INV))
    }
    #[doc = "Encode a [**ASNNAT**](Opcode::ASNNAT) instruction."]
    pub fn asnnat(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ASNNAT)) }
    #[doc = "Encode a [**ASNNATINV**](Opcode::ASNNATINV) instruction."]
    pub fn asnnatinv(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ASNNATINV)) }
    #[doc = "Encode a [**ASNNAT1**](Opcode::ASNNAT1) instruction."]
    pub fn asnnat1(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ASNNAT1)) }
    #[doc = "Encode a [**ASNNAT1INV**](Opcode::ASNNAT1INV) instruction."]
    pub fn asnnat1inv(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::ASNNAT1INV))
    }
    #[doc = "Encode a [**ASNNAT2**](Opcode::ASNNAT2) instruction."]
    pub fn asnnat2(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ASNNAT2)) }
    #[doc = "Encode a [**ASNNAT2INV**](Opcode::ASNNAT2INV) instruction."]
    pub fn asnnat2inv(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::ASNNAT2INV))
    }
    #[doc = "Encode a [**ASNNAT4**](Opcode::ASNNAT4) instruction."]
    pub fn asnnat4(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ASNNAT4)) }
    #[doc = "Encode a [**ASNNAT4INV**](Opcode::ASNNAT4INV) instruction."]
    pub fn asnnat4inv(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::ASNNAT4INV))
    }
    #[doc = "Encode a [**ASNNONSCALAR**](Opcode::ASNNONSCALAR) instruction.\n\n## Operands\n\n- length: Number of bytes to copy.\n"]
    pub fn asnnonscalar(&mut self, length: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::ASNNONSCALAR).with_operand(Operand::Nat4(length)))
    }
    #[doc = "Encode a [**ASNNONSCALARINV**](Opcode::ASNNONSCALARINV) instruction.\n\n## Operands\n\n- length: Number of bytes to copy.\n"]
    pub fn asnnonscalarinv(&mut self, length: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::ASNNONSCALARINV).with_operand(Operand::Nat4(length)))
    }
    #[doc = "Encode a [**ASNPTR**](Opcode::ASNPTR) instruction."]
    pub fn asnptr(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ASNPTR)) }
    #[doc = "Encode a [**ASNPTRINV**](Opcode::ASNPTRINV) instruction."]
    pub fn asnptrinv(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ASNPTRINV)) }
    #[doc = "Encode a [**ASNREAL**](Opcode::ASNREAL) instruction."]
    pub fn asnreal(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ASNREAL)) }
    #[doc = "Encode a [**ASNREALINV**](Opcode::ASNREALINV) instruction."]
    pub fn asnrealinv(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::ASNREALINV))
    }
    #[doc = "Encode a [**ASNREAL4**](Opcode::ASNREAL4) instruction."]
    pub fn asnreal4(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ASNREAL4)) }
    #[doc = "Encode a [**ASNREAL4INV**](Opcode::ASNREAL4INV) instruction."]
    pub fn asnreal4inv(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::ASNREAL4INV))
    }
    #[doc = "Encode a [**ASNREAL8**](Opcode::ASNREAL8) instruction."]
    pub fn asnreal8(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ASNREAL8)) }
    #[doc = "Encode a [**ASNREAL8INV**](Opcode::ASNREAL8INV) instruction."]
    pub fn asnreal8inv(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::ASNREAL8INV))
    }
    #[doc = "Encode a [**ASNSTR**](Opcode::ASNSTR) instruction."]
    pub fn asnstr(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ASNSTR)) }
    #[doc = "Encode a [**ASNSTRINV**](Opcode::ASNSTRINV) instruction."]
    pub fn asnstrinv(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ASNSTRINV)) }
    #[doc = "Encode a [**CALL**](Opcode::CALL) instruction.\n\n## Operands\n\n- address_offset: Offset to the call address in the stack.\n"]
    pub fn call(&mut self, address_offset: Offset) -> InstructionRef {
        self.add(Instruction::new(Opcode::CALL).with_operand(Operand::Offset(address_offset)))
    }
    #[doc = "Encode a [**CALLIMPLEMENTBY**](Opcode::CALLIMPLEMENTBY) instruction.\n\n## Operands\n\n- address_offset: Offset to the patched-in implement-by call address in the code section.\n"]
    pub fn callimplementby(&mut self, address_offset: RelocatableOffset) -> InstructionRef {
        self.add(
            Instruction::new(Opcode::CALLIMPLEMENTBY)
                .with_operand(Operand::RelocatableOffset(address_offset)),
        )
    }
    #[doc = "Encode a [**CASE**](Opcode::CASE) instruction.\n\n## Operands\n\n- descriptor: Offset to the case descriptor table describing the jump targets\n"]
    pub fn case(&mut self, descriptor: Offset) -> InstructionRef {
        self.add(Instruction::new(Opcode::CASE).with_operand(Operand::Offset(descriptor)))
    }
    #[doc = "Encode a [**CHARTOCSTR**](Opcode::CHARTOCSTR) instruction."]
    pub fn chartocstr(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::CHARTOCSTR))
    }
    #[doc = "Encode a [**CHARTOSTR**](Opcode::CHARTOSTR) instruction."]
    pub fn chartostr(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::CHARTOSTR)) }
    #[doc = "Encode a [**CHARTOSTRLEFT**](Opcode::CHARTOSTRLEFT) instruction."]
    pub fn chartostrleft(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::CHARTOSTRLEFT))
    }
    #[doc = "Encode a [**CHKCHRSTRSIZE**](Opcode::CHKCHRSTRSIZE) instruction.\n\n## Operands\n\n- expected_length: Expected length of the `char(N)` value.\n"]
    pub fn chkchrstrsize(&mut self, expected_length: Nat4) -> InstructionRef {
        self.add(
            Instruction::new(Opcode::CHKCHRSTRSIZE).with_operand(Operand::Nat4(expected_length)),
        )
    }
    #[doc = "Encode a [**CHKCSTRRANGE**](Opcode::CHKCSTRRANGE) instruction.\n\n## Operands\n\n- max_length: Maximum string byte length of the `char(N)` value.\n"]
    pub fn chkcstrrange(&mut self, max_length: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::CHKCSTRRANGE).with_operand(Operand::Nat4(max_length)))
    }
    #[doc = "Encode a [**CHKRANGE**](Opcode::CHKRANGE) instruction.\n\n## Operands\n\n- stack_offset: Offset to the value to check within the operand stack\n- min: Minimum bound of the accepted value range.\n- max: Maximum bound of the accepted value range.\n- check_type: What the value range check is asserting.\n"]
    pub fn chkrange(
        &mut self,
        stack_offset: Offset,
        min: Int4,
        max: Int4,
        check_type: CheckKind,
    ) -> InstructionRef {
        self.add(
            Instruction::new(Opcode::CHKRANGE)
                .with_operand(Operand::Offset(stack_offset))
                .with_operand(Operand::Int4(min))
                .with_operand(Operand::Int4(max))
                .with_operand(Operand::CheckKind(check_type)),
        )
    }
    #[doc = "Encode a [**CHKSTRRANGE**](Opcode::CHKSTRRANGE) instruction.\n\n## Operands\n\n- max_length: Maximum string byte length of the `string` value.\n"]
    pub fn chkstrrange(&mut self, max_length: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::CHKSTRRANGE).with_operand(Operand::Nat4(max_length)))
    }
    #[doc = "Encode a [**CHKSTRSIZE**](Opcode::CHKSTRSIZE) instruction.\n\n## Operands\n\n- expected_length: Expected length of the `string` value.\n"]
    pub fn chkstrsize(&mut self, expected_length: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::CHKSTRSIZE).with_operand(Operand::Nat4(expected_length)))
    }
    #[doc = "Encode a [**CSTRTOCHAR**](Opcode::CSTRTOCHAR) instruction."]
    pub fn cstrtochar(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::CSTRTOCHAR))
    }
    #[doc = "Encode a [**CSTRTOSTR**](Opcode::CSTRTOSTR) instruction."]
    pub fn cstrtostr(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::CSTRTOSTR)) }
    #[doc = "Encode a [**CSTRTOSTRLEFT**](Opcode::CSTRTOSTRLEFT) instruction."]
    pub fn cstrtostrleft(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::CSTRTOSTRLEFT))
    }
    #[doc = "Encode a [**DECSP**](Opcode::DECSP) instruction.\n\n## Operands\n\n- size: Amount of bytes to push onto the operand stack.\n"]
    pub fn decsp(&mut self, size: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::DECSP).with_operand(Operand::Nat4(size)))
    }
    #[doc = "Encode a [**DIVINT**](Opcode::DIVINT) instruction."]
    pub fn divint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::DIVINT)) }
    #[doc = "Encode a [**DIVNAT**](Opcode::DIVNAT) instruction."]
    pub fn divnat(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::DIVNAT)) }
    #[doc = "Encode a [**DIVREAL**](Opcode::DIVREAL) instruction."]
    pub fn divreal(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::DIVREAL)) }
    #[doc = "Encode a [**EQADDR**](Opcode::EQADDR) instruction."]
    pub fn eqaddr(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::EQADDR)) }
    #[doc = "Encode a [**EQCHARN**](Opcode::EQCHARN) instruction.\n\n## Operands\n\n- length: Byte length of the `char(N)` type.\n"]
    pub fn eqcharn(&mut self, length: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::EQCHARN).with_operand(Operand::Nat4(length)))
    }
    #[doc = "Encode a [**EQINT**](Opcode::EQINT) instruction."]
    pub fn eqint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::EQINT)) }
    #[doc = "Encode a [**EQINTNAT**](Opcode::EQINTNAT) instruction."]
    pub fn eqintnat(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::EQINTNAT)) }
    #[doc = "Encode a [**EQNAT**](Opcode::EQNAT) instruction."]
    pub fn eqnat(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::EQNAT)) }
    #[doc = "Encode a [**EQREAL**](Opcode::EQREAL) instruction."]
    pub fn eqreal(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::EQREAL)) }
    #[doc = "Encode a [**EQSET**](Opcode::EQSET) instruction.\n\n## Operands\n\n- set_length: Length of the set, in bytes.\n"]
    pub fn eqset(&mut self, set_length: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::EQSET).with_operand(Operand::Nat4(set_length)))
    }
    #[doc = "Encode a [**EQSTR**](Opcode::EQSTR) instruction."]
    pub fn eqstr(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::EQSTR)) }
    #[doc = "Encode a [**EXPINTINT**](Opcode::EXPINTINT) instruction."]
    pub fn expintint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::EXPINTINT)) }
    #[doc = "Encode a [**EXPREALINT**](Opcode::EXPREALINT) instruction."]
    pub fn exprealint(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::EXPREALINT))
    }
    #[doc = "Encode a [**EXPREALREAL**](Opcode::EXPREALREAL) instruction."]
    pub fn exprealreal(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::EXPREALREAL))
    }
    #[doc = "Encode a [**FETCHADDR**](Opcode::FETCHADDR) instruction."]
    pub fn fetchaddr(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::FETCHADDR)) }
    #[doc = "Encode a [**FETCHBOOL**](Opcode::FETCHBOOL) instruction."]
    pub fn fetchbool(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::FETCHBOOL)) }
    #[doc = "Encode a [**FETCHINT**](Opcode::FETCHINT) instruction."]
    pub fn fetchint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::FETCHINT)) }
    #[doc = "Encode a [**FETCHINT1**](Opcode::FETCHINT1) instruction."]
    pub fn fetchint1(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::FETCHINT1)) }
    #[doc = "Encode a [**FETCHINT2**](Opcode::FETCHINT2) instruction."]
    pub fn fetchint2(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::FETCHINT2)) }
    #[doc = "Encode a [**FETCHINT4**](Opcode::FETCHINT4) instruction."]
    pub fn fetchint4(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::FETCHINT4)) }
    #[doc = "Encode a [**FETCHNAT**](Opcode::FETCHNAT) instruction."]
    pub fn fetchnat(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::FETCHNAT)) }
    #[doc = "Encode a [**FETCHNAT1**](Opcode::FETCHNAT1) instruction."]
    pub fn fetchnat1(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::FETCHNAT1)) }
    #[doc = "Encode a [**FETCHNAT2**](Opcode::FETCHNAT2) instruction."]
    pub fn fetchnat2(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::FETCHNAT2)) }
    #[doc = "Encode a [**FETCHNAT4**](Opcode::FETCHNAT4) instruction."]
    pub fn fetchnat4(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::FETCHNAT4)) }
    #[doc = "Encode a [**FETCHPTR**](Opcode::FETCHPTR) instruction."]
    pub fn fetchptr(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::FETCHPTR)) }
    #[doc = "Encode a [**FETCHREAL**](Opcode::FETCHREAL) instruction."]
    pub fn fetchreal(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::FETCHREAL)) }
    #[doc = "Encode a [**FETCHREAL4**](Opcode::FETCHREAL4) instruction."]
    pub fn fetchreal4(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::FETCHREAL4))
    }
    #[doc = "Encode a [**FETCHREAL8**](Opcode::FETCHREAL8) instruction."]
    pub fn fetchreal8(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::FETCHREAL8))
    }
    #[doc = "Encode a [**FETCHSET**](Opcode::FETCHSET) instruction.\n\n## Operands\n\n- set_length: Length of the set, in bytes.\n"]
    pub fn fetchset(&mut self, set_length: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::FETCHSET).with_operand(Operand::Nat4(set_length)))
    }
    #[doc = "Encode a [**FETCHSTR**](Opcode::FETCHSTR) instruction."]
    pub fn fetchstr(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::FETCHSTR)) }
    #[doc = "Encode a [**FOR**](Opcode::FOR) instruction.\n\n## Operands\n\n- skip_offset: Offset to jump over for-loop body, in bytes.\n"]
    pub fn for_(&mut self, skip_offset: Offset) -> InstructionRef {
        self.add(Instruction::new(Opcode::FOR).with_operand(Operand::Offset(skip_offset)))
    }
    #[doc = "Encode a [**ENDFOR**](Opcode::ENDFOR) instruction.\n\n## Operands\n\n- offset: Offset to jump to the start of the for-loop body, in bytes.\n"]
    pub fn endfor(&mut self, offset: Offset) -> InstructionRef {
        self.add(Instruction::new(Opcode::ENDFOR).with_operand(Operand::Offset(offset)))
    }
    #[doc = "Encode a [**GECHARN**](Opcode::GECHARN) instruction.\n\n## Operands\n\n- length: Byte length of the `char(N)` type.\n"]
    pub fn gecharn(&mut self, length: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::GECHARN).with_operand(Operand::Nat4(length)))
    }
    #[doc = "Encode a [**GECLASS**](Opcode::GECLASS) instruction."]
    pub fn geclass(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::GECLASS)) }
    #[doc = "Encode a [**GEINT**](Opcode::GEINT) instruction."]
    pub fn geint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::GEINT)) }
    #[doc = "Encode a [**GEINTNAT**](Opcode::GEINTNAT) instruction."]
    pub fn geintnat(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::GEINTNAT)) }
    #[doc = "Encode a [**GENAT**](Opcode::GENAT) instruction."]
    pub fn genat(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::GENAT)) }
    #[doc = "Encode a [**GENATINT**](Opcode::GENATINT) instruction."]
    pub fn genatint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::GENATINT)) }
    #[doc = "Encode a [**GEREAL**](Opcode::GEREAL) instruction."]
    pub fn gereal(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::GEREAL)) }
    #[doc = "Encode a [**GESET**](Opcode::GESET) instruction.\n\n## Operands\n\n- set_length: Length of the set, in bytes.\n"]
    pub fn geset(&mut self, set_length: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::GESET).with_operand(Operand::Nat4(set_length)))
    }
    #[doc = "Encode a [**GESTR**](Opcode::GESTR) instruction."]
    pub fn gestr(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::GESTR)) }
    #[doc = "Encode a [**GET**](Opcode::GET) instruction.\n\n## Operands\n\n- get_kind: Which kind of item to get.\n"]
    pub fn get(&mut self, get_kind: GetKind) -> InstructionRef {
        self.add(Instruction::new(Opcode::GET).with_operand(Operand::GetKind(get_kind)))
    }
    #[doc = "Encode a [**GTCLASS**](Opcode::GTCLASS) instruction."]
    pub fn gtclass(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::GTCLASS)) }
    #[doc = "Encode a [**IF**](Opcode::IF) instruction.\n\n## Operands\n\n- offset: Offset to jump forward by if `test` is zero, in bytes.\n"]
    pub fn if_(&mut self, offset: Offset) -> InstructionRef {
        self.add(Instruction::new(Opcode::IF).with_operand(Operand::Offset(offset)))
    }
    #[doc = "Encode a [**INCSP**](Opcode::INCSP) instruction.\n\n## Operands\n\n- size: Amount of bytes to pop off the operand stack.\n"]
    pub fn incsp(&mut self, size: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::INCSP).with_operand(Operand::Nat4(size)))
    }
    #[doc = "Encode a [**INFIXAND**](Opcode::INFIXAND) instruction.\n\n## Operands\n\n- offset: Offset to jump forward by if `test` is zero, in bytes.\n"]
    pub fn infixand(&mut self, offset: Offset) -> InstructionRef {
        self.add(Instruction::new(Opcode::INFIXAND).with_operand(Operand::Offset(offset)))
    }
    #[doc = "Encode a [**INFIXOR**](Opcode::INFIXOR) instruction.\n\n## Operands\n\n- offset: Offset to jump forward by if `test` is non-zero, in bytes.\n"]
    pub fn infixor(&mut self, offset: Offset) -> InstructionRef {
        self.add(Instruction::new(Opcode::INFIXOR).with_operand(Operand::Offset(offset)))
    }
    #[doc = "Encode a [**INTREAL**](Opcode::INTREAL) instruction."]
    pub fn intreal(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::INTREAL)) }
    #[doc = "Encode a [**INTREALLEFT**](Opcode::INTREALLEFT) instruction."]
    pub fn intrealleft(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::INTREALLEFT))
    }
    #[doc = "Encode a [**LECHARN**](Opcode::LECHARN) instruction.\n\n## Operands\n\n- length: Byte length of the `char(N)` type.\n"]
    pub fn lecharn(&mut self, length: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::LECHARN).with_operand(Operand::Nat4(length)))
    }
    #[doc = "Encode a [**LECLASS**](Opcode::LECLASS) instruction."]
    pub fn leclass(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::LECLASS)) }
    #[doc = "Encode a [**LEINT**](Opcode::LEINT) instruction."]
    pub fn leint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::LEINT)) }
    #[doc = "Encode a [**LEINTNAT**](Opcode::LEINTNAT) instruction."]
    pub fn leintnat(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::LEINTNAT)) }
    #[doc = "Encode a [**LENAT**](Opcode::LENAT) instruction."]
    pub fn lenat(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::LENAT)) }
    #[doc = "Encode a [**LENATINT**](Opcode::LENATINT) instruction."]
    pub fn lenatint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::LENATINT)) }
    #[doc = "Encode a [**LEREAL**](Opcode::LEREAL) instruction."]
    pub fn lereal(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::LEREAL)) }
    #[doc = "Encode a [**LESET**](Opcode::LESET) instruction.\n\n## Operands\n\n- set_length: Length of the set, in bytes.\n"]
    pub fn leset(&mut self, set_length: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::LESET).with_operand(Operand::Nat4(set_length)))
    }
    #[doc = "Encode a [**LESTR**](Opcode::LESTR) instruction."]
    pub fn lestr(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::LESTR)) }
    #[doc = "Encode a [**JUMP**](Opcode::JUMP) instruction.\n\n## Operands\n\n- offset: Offset to jump forward by, in bytes.\n"]
    pub fn jump(&mut self, offset: Offset) -> InstructionRef {
        self.add(Instruction::new(Opcode::JUMP).with_operand(Operand::Offset(offset)))
    }
    #[doc = "Encode a [**JUMPB**](Opcode::JUMPB) instruction.\n\n## Operands\n\n- offset: Offset to jump backwards by, in bytes.\n"]
    pub fn jumpb(&mut self, offset: Offset) -> InstructionRef {
        self.add(Instruction::new(Opcode::JUMPB).with_operand(Operand::Offset(offset)))
    }
    #[doc = "Encode a [**LOCATEARG**](Opcode::LOCATEARG) instruction.\n\n## Operands\n\n- offset: Offset in the operand stack.\n"]
    pub fn locatearg(&mut self, offset: Offset) -> InstructionRef {
        self.add(Instruction::new(Opcode::LOCATEARG).with_operand(Operand::Offset(offset)))
    }
    #[doc = "Encode a [**LOCATELOCAL**](Opcode::LOCATELOCAL) instruction.\n\n## Operands\n\n- offset: Offset in the locals area.\n"]
    pub fn locatelocal(&mut self, offset: Offset) -> InstructionRef {
        self.add(Instruction::new(Opcode::LOCATELOCAL).with_operand(Operand::Offset(offset)))
    }
    #[doc = "Encode a [**LOCATEPARM**](Opcode::LOCATEPARM) instruction.\n\n## Operands\n\n- offset: Offset from the start of the call frame.\n"]
    pub fn locateparm(&mut self, offset: Offset) -> InstructionRef {
        self.add(Instruction::new(Opcode::LOCATEPARM).with_operand(Operand::Offset(offset)))
    }
    #[doc = "Encode a [**LOCATETEMP**](Opcode::LOCATETEMP) instruction.\n\n## Operands\n\n- frame_size: Size of the call frame.\n- offset: Offset in the temporary area.\n"]
    pub fn locatetemp(&mut self, frame_size: Nat4, offset: Offset) -> InstructionRef {
        self.add(
            Instruction::new(Opcode::LOCATETEMP)
                .with_operand(Operand::Nat4(frame_size))
                .with_operand(Operand::Offset(offset)),
        )
    }
    #[doc = "Encode a [**LTCLASS**](Opcode::LTCLASS) instruction."]
    pub fn ltclass(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::LTCLASS)) }
    #[doc = "Encode a [**MODINT**](Opcode::MODINT) instruction."]
    pub fn modint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::MODINT)) }
    #[doc = "Encode a [**MODNAT**](Opcode::MODNAT) instruction."]
    pub fn modnat(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::MODNAT)) }
    #[doc = "Encode a [**MODREAL**](Opcode::MODREAL) instruction."]
    pub fn modreal(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::MODREAL)) }
    #[doc = "Encode a [**MULINT**](Opcode::MULINT) instruction."]
    pub fn mulint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::MULINT)) }
    #[doc = "Encode a [**MULNAT**](Opcode::MULNAT) instruction."]
    pub fn mulnat(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::MULNAT)) }
    #[doc = "Encode a [**MULREAL**](Opcode::MULREAL) instruction."]
    pub fn mulreal(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::MULREAL)) }
    #[doc = "Encode a [**MULSET**](Opcode::MULSET) instruction.\n\n## Operands\n\n- set_length: Length of the set, in bytes.\n"]
    pub fn mulset(&mut self, set_length: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::MULSET).with_operand(Operand::Nat4(set_length)))
    }
    #[doc = "Encode a [**NATREAL**](Opcode::NATREAL) instruction."]
    pub fn natreal(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::NATREAL)) }
    #[doc = "Encode a [**NATREALLEFT**](Opcode::NATREALLEFT) instruction."]
    pub fn natrealleft(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::NATREALLEFT))
    }
    #[doc = "Encode a [**NEGINT**](Opcode::NEGINT) instruction."]
    pub fn negint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::NEGINT)) }
    #[doc = "Encode a [**NEGREAL**](Opcode::NEGREAL) instruction."]
    pub fn negreal(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::NEGREAL)) }
    #[doc = "Encode a [**NOT**](Opcode::NOT) instruction."]
    pub fn not(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::NOT)) }
    #[doc = "Encode a [**OR**](Opcode::OR) instruction."]
    pub fn or(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::OR)) }
    #[doc = "Encode a [**PROC**](Opcode::PROC) instruction.\n\n## Operands\n\n- frame_size: Size of the call frame to allocate for locals and temporaries.\n"]
    pub fn proc(&mut self, frame_size: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::PROC).with_operand(Operand::Nat4(frame_size)))
    }
    #[doc = "Encode a [**PUSHADDR**](Opcode::PUSHADDR) instruction.\n\n## Operands\n\n- addr: Absolute address to refer to.\n"]
    pub fn pushaddr(&mut self, addr: Addrint) -> InstructionRef {
        self.add(Instruction::new(Opcode::PUSHADDR).with_operand(Operand::Addrint(addr)))
    }
    #[doc = "Encode a [**PUSHADDR1**](Opcode::PUSHADDR1) instruction.\n\n## Operands\n\n- offset: Runtime-resolved offset within a section.\n"]
    pub fn pushaddr1(&mut self, offset: RelocatableOffset) -> InstructionRef {
        self.add(
            Instruction::new(Opcode::PUSHADDR1).with_operand(Operand::RelocatableOffset(offset)),
        )
    }
    #[doc = "Encode a [**PUSHCOPY**](Opcode::PUSHCOPY) instruction."]
    pub fn pushcopy(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::PUSHCOPY)) }
    #[doc = "Encode a [**PUSHINT**](Opcode::PUSHINT) instruction.\n\n## Operands\n\n- literal: Literal value to push.\n"]
    pub fn pushint(&mut self, literal: Int4) -> InstructionRef {
        self.add(Instruction::new(Opcode::PUSHINT).with_operand(Operand::Int4(literal)))
    }
    #[doc = "Encode a [**PUSHINT1**](Opcode::PUSHINT1) instruction.\n\n## Operands\n\n- literal: Literal value to push.\n"]
    pub fn pushint1(&mut self, literal: Int1) -> InstructionRef {
        self.add(Instruction::new(Opcode::PUSHINT1).with_operand(Operand::Int1(literal)))
    }
    #[doc = "Encode a [**PUSHINT2**](Opcode::PUSHINT2) instruction.\n\n## Operands\n\n- literal: Literal value to push.\n"]
    pub fn pushint2(&mut self, literal: Int2) -> InstructionRef {
        self.add(Instruction::new(Opcode::PUSHINT2).with_operand(Operand::Int2(literal)))
    }
    #[doc = "Encode a [**PUSHREAL**](Opcode::PUSHREAL) instruction.\n\n## Operands\n\n- literal: Literal value to push.\n"]
    pub fn pushreal(&mut self, literal: Real8) -> InstructionRef {
        self.add(Instruction::new(Opcode::PUSHREAL).with_operand(Operand::Real8(literal)))
    }
    #[doc = "Encode a [**PUSHVAL0**](Opcode::PUSHVAL0) instruction."]
    pub fn pushval0(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::PUSHVAL0)) }
    #[doc = "Encode a [**PUSHVAL1**](Opcode::PUSHVAL1) instruction."]
    pub fn pushval1(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::PUSHVAL1)) }
    #[doc = "Encode a [**PUT**](Opcode::PUT) instruction.\n\n## Operands\n\n- put_kind: Which kind of item to put.\n"]
    pub fn put(&mut self, put_kind: PutKind) -> InstructionRef {
        self.add(Instruction::new(Opcode::PUT).with_operand(Operand::PutKind(put_kind)))
    }
    #[doc = "Encode a [**REALDIVIDE**](Opcode::REALDIVIDE) instruction."]
    pub fn realdivide(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::REALDIVIDE))
    }
    #[doc = "Encode a [**REMINT**](Opcode::REMINT) instruction."]
    pub fn remint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::REMINT)) }
    #[doc = "Encode a [**REMREAL**](Opcode::REMREAL) instruction."]
    pub fn remreal(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::REMREAL)) }
    #[doc = "Encode a [**RETURN**](Opcode::RETURN) instruction."]
    pub fn return_(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::RETURN)) }
    #[doc = "Encode a [**INCLINENO**](Opcode::INCLINENO) instruction."]
    pub fn inclineno(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::INCLINENO)) }
    #[doc = "Encode a [**SETFILENO**](Opcode::SETFILENO) instruction.\n\n## Operands\n\n- file_no: File number to set location to.\n- line_no: Line number to set location to.\n"]
    pub fn setfileno(&mut self, file_no: Nat2, line_no: Nat2) -> InstructionRef {
        self.add(
            Instruction::new(Opcode::SETFILENO)
                .with_operand(Operand::Nat2(file_no))
                .with_operand(Operand::Nat2(line_no)),
        )
    }
    #[doc = "Encode a [**SETLINENO**](Opcode::SETLINENO) instruction.\n\n## Operands\n\n- line_no: Line number to set location to.\n"]
    pub fn setlineno(&mut self, line_no: Nat2) -> InstructionRef {
        self.add(Instruction::new(Opcode::SETLINENO).with_operand(Operand::Nat2(line_no)))
    }
    #[doc = "Encode a [**SETSTDSTREAM**](Opcode::SETSTDSTREAM) instruction.\n\n## Operands\n\n- kind: Which standard stream handle to retrieve.\n"]
    pub fn setstdstream(&mut self, kind: StdStreamKind) -> InstructionRef {
        self.add(Instruction::new(Opcode::SETSTDSTREAM).with_operand(Operand::StdStreamKind(kind)))
    }
    #[doc = "Encode a [**SETSTREAM**](Opcode::SETSTREAM) instruction.\n\n## Operands\n\n- kind: Which operation to prepare the stream for.\n"]
    pub fn setstream(&mut self, kind: StreamKind) -> InstructionRef {
        self.add(Instruction::new(Opcode::SETSTREAM).with_operand(Operand::StreamKind(kind)))
    }
    #[doc = "Encode a [**SHL**](Opcode::SHL) instruction."]
    pub fn shl(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::SHL)) }
    #[doc = "Encode a [**SHR**](Opcode::SHR) instruction."]
    pub fn shr(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::SHR)) }
    #[doc = "Encode a [**STRTOCHAR**](Opcode::STRTOCHAR) instruction."]
    pub fn strtochar(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::STRTOCHAR)) }
    #[doc = "Encode a [**SUBINT**](Opcode::SUBINT) instruction."]
    pub fn subint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::SUBINT)) }
    #[doc = "Encode a [**SUBINTNAT**](Opcode::SUBINTNAT) instruction."]
    pub fn subintnat(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::SUBINTNAT)) }
    #[doc = "Encode a [**SUBNAT**](Opcode::SUBNAT) instruction."]
    pub fn subnat(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::SUBNAT)) }
    #[doc = "Encode a [**SUBNATINT**](Opcode::SUBNATINT) instruction."]
    pub fn subnatint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::SUBNATINT)) }
    #[doc = "Encode a [**SUBREAL**](Opcode::SUBREAL) instruction."]
    pub fn subreal(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::SUBREAL)) }
    #[doc = "Encode a [**SUBSET**](Opcode::SUBSET) instruction.\n\n## Operands\n\n- set_length: Length of the set, in bytes.\n"]
    pub fn subset(&mut self, set_length: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::SUBSET).with_operand(Operand::Nat4(set_length)))
    }
    #[doc = "Encode a [**UNINITADDR**](Opcode::UNINITADDR) instruction."]
    pub fn uninitaddr(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::UNINITADDR))
    }
    #[doc = "Encode a [**UNINITBOOLEAN**](Opcode::UNINITBOOLEAN) instruction."]
    pub fn uninitboolean(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::UNINITBOOLEAN))
    }
    #[doc = "Encode a [**UNINITINT**](Opcode::UNINITINT) instruction."]
    pub fn uninitint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::UNINITINT)) }
    #[doc = "Encode a [**UNINITNAT**](Opcode::UNINITNAT) instruction."]
    pub fn uninitnat(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::UNINITNAT)) }
    #[doc = "Encode a [**UNINITREAL**](Opcode::UNINITREAL) instruction."]
    pub fn uninitreal(&mut self) -> InstructionRef {
        self.add(Instruction::new(Opcode::UNINITREAL))
    }
    #[doc = "Encode a [**UNINITSTR**](Opcode::UNINITSTR) instruction."]
    pub fn uninitstr(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::UNINITSTR)) }
    #[doc = "Encode a [**XOR**](Opcode::XOR) instruction."]
    pub fn xor(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::XOR)) }
    #[doc = "Encode a [**XORSET**](Opcode::XORSET) instruction.\n\n## Operands\n\n- set_length: Length of the set, in bytes.\n"]
    pub fn xorset(&mut self, set_length: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::XORSET).with_operand(Operand::Nat4(set_length)))
    }
    #[doc = "Encode a [**BREAK**](Opcode::BREAK) instruction."]
    pub fn break_(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::BREAK)) }
    #[doc = "Encode a [**SYSEXIT**](Opcode::SYSEXIT) instruction."]
    pub fn sysexit(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::SYSEXIT)) }
    #[doc = "Encode a [**ILLEGAL**](Opcode::ILLEGAL) instruction."]
    pub fn illegal(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ILLEGAL)) }
}
