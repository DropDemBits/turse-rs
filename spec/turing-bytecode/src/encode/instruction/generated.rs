//! Generated by `xtask codegen turing-bytecode`, do not edit by hand

use crate::encode::instruction::{Instruction, InstructionEncoder, InstructionRef};
use crate::instruction::*;
use byteorder::{WriteBytesExt, LE};
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[doc = "An operand for an encoded instruction."]
pub enum Operand {
    Nat4(Nat4),
    Offset(Offset),
    RelocatableOffset(RelocatableOffset),
    AbortReason(AbortReason),
}
impl Operand {
    #[doc = "Size of the operand, in bytes."]
    pub fn size(&self) -> usize {
        match self {
            Self::Nat4(_) => 4usize,
            Self::Offset(_) => 4usize,
            Self::RelocatableOffset(_) => 8usize,
            Self::AbortReason(_) => 4usize,
        }
    }
    #[doc = "Encodes the operand into the equivalent byte representation."]
    pub fn encode(&self, out: &mut impl std::io::Write) -> std::io::Result<()> {
        match self {
            Self::Nat4(value) => out.write_u32::<LE>(*value),
            Self::Offset(value) => out.write_u32::<LE>(*value),
            Self::RelocatableOffset(value) => value.encode(out),
            Self::AbortReason(value) => value.encode(out),
        }
    }
}
pub(crate) const MAX_OPERANDS: usize = 2usize;
impl RelocatableOffset {
    #[doc = "Encodes the type into the equivalent byte representation."]
    pub fn encode(&self, out: &mut impl std::io::Write) -> std::io::Result<()> {
        out.write_u32::<LE>(self.link)?;
        out.write_u32::<LE>(self.offset)?;
        Ok(())
    }
}
impl AbortReason {
    #[doc = "Encodes the type into the equivalent byte representation."]
    pub fn encode(&self, out: &mut impl std::io::Write) -> std::io::Result<()> {
        out.write_u32::<LE>(*self as u32)
    }
}
impl InstructionEncoder {
    #[doc = "Encode a [**ABORT**](Opcode::ABORT) instruction.\n\n## Operands\n\n- abort_kind: What is the reason for aborting\n"]
    pub fn abort(&mut self, abort_kind: AbortReason) -> InstructionRef {
        self.add(Instruction::new(Opcode::ABORT).with_operand(Operand::AbortReason(abort_kind)))
    }
    #[doc = "Encode a [**ABORTCOND**](Opcode::ABORTCOND) instruction.\n\n## Operands\n\n- abort_kind: What is the reason for aborting\n"]
    pub fn abortcond(&mut self, abort_kind: AbortReason) -> InstructionRef {
        self.add(Instruction::new(Opcode::ABORTCOND).with_operand(Operand::AbortReason(abort_kind)))
    }
    #[doc = "Encode a [**ADDINT**](Opcode::ADDINT) instruction."]
    pub fn addint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ADDINT)) }
    #[doc = "Encode a [**ADDINTNAT**](Opcode::ADDINTNAT) instruction."]
    pub fn addintnat(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ADDINTNAT)) }
    #[doc = "Encode a [**ADDNAT**](Opcode::ADDNAT) instruction."]
    pub fn addnat(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ADDNAT)) }
    #[doc = "Encode a [**ADDNATINT**](Opcode::ADDNATINT) instruction."]
    pub fn addnatint(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ADDNATINT)) }
    #[doc = "Encode a [**ADDREAL**](Opcode::ADDREAL) instruction."]
    pub fn addreal(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::ADDREAL)) }
    #[doc = "Encode a [**CALL**](Opcode::CALL) instruction.\n\n## Operands\n\n- address_offset: Offset to the call address in the stack\n"]
    pub fn call(&mut self, address_offset: Offset) -> InstructionRef {
        self.add(Instruction::new(Opcode::CALL).with_operand(Operand::Offset(address_offset)))
    }
    #[doc = "Encode a [**CASE**](Opcode::CASE) instruction.\n\n## Operands\n\n- descriptor: Offset to the case descriptor table describing the jump targets\n"]
    pub fn case(&mut self, descriptor: Offset) -> InstructionRef {
        self.add(Instruction::new(Opcode::CASE).with_operand(Operand::Offset(descriptor)))
    }
    #[doc = "Encode a [**LOCATELOCAL**](Opcode::LOCATELOCAL) instruction.\n\n## Operands\n\n- offset: Offset in the locals area\n"]
    pub fn locatelocal(&mut self, offset: Offset) -> InstructionRef {
        self.add(Instruction::new(Opcode::LOCATELOCAL).with_operand(Operand::Offset(offset)))
    }
    #[doc = "Encode a [**LOCATETEMP**](Opcode::LOCATETEMP) instruction.\n\n## Operands\n\n- frame_size: Size of the call frame.\n- offset: Offset in the temporary area\n"]
    pub fn locatetemp(&mut self, frame_size: Nat4, offset: Offset) -> InstructionRef {
        self.add(
            Instruction::new(Opcode::LOCATETEMP)
                .with_operand(Operand::Nat4(frame_size))
                .with_operand(Operand::Offset(offset)),
        )
    }
    #[doc = "Encode a [**JUMP**](Opcode::JUMP) instruction.\n\n## Operands\n\n- offset: Offset to jump forward by, in bytes\n"]
    pub fn jump(&mut self, offset: Offset) -> InstructionRef {
        self.add(Instruction::new(Opcode::JUMP).with_operand(Operand::Offset(offset)))
    }
    #[doc = "Encode a [**JUMPB**](Opcode::JUMPB) instruction.\n\n## Operands\n\n- offset: Offset to jump backwards by, in bytes\n"]
    pub fn jumpb(&mut self, offset: Offset) -> InstructionRef {
        self.add(Instruction::new(Opcode::JUMPB).with_operand(Operand::Offset(offset)))
    }
    #[doc = "Encode a [**PROC**](Opcode::PROC) instruction.\n\n## Operands\n\n- frame_size: Size of the call frame to allocate for locals and temporaries.\n"]
    pub fn proc(&mut self, frame_size: Nat4) -> InstructionRef {
        self.add(Instruction::new(Opcode::PROC).with_operand(Operand::Nat4(frame_size)))
    }
    #[doc = "Encode a [**PUSHADDR1**](Opcode::PUSHADDR1) instruction.\n\n## Operands\n\n- offset: Runtime-resolved offset within a section.\n"]
    pub fn pushaddr1(&mut self, offset: RelocatableOffset) -> InstructionRef {
        self.add(
            Instruction::new(Opcode::PUSHADDR1).with_operand(Operand::RelocatableOffset(offset)),
        )
    }
    #[doc = "Encode a [**PUSHVAL0**](Opcode::PUSHVAL0) instruction."]
    pub fn pushval0(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::PUSHVAL0)) }
    #[doc = "Encode a [**PUSHVAL1**](Opcode::PUSHVAL1) instruction."]
    pub fn pushval1(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::PUSHVAL1)) }
    #[doc = "Encode a [**RETURN**](Opcode::RETURN) instruction."]
    pub fn return_(&mut self) -> InstructionRef { self.add(Instruction::new(Opcode::RETURN)) }
}
