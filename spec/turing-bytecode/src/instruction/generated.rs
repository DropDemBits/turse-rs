//! Generated by `xtask codegen turing-bytecode`, do not edit by hand

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u32)]
#[doc = "An opcode for an instruction."]
pub enum Opcode {
    #[doc = "Abort\n\nAlways aborts program execution."]
    ABORT = 0x0,
    #[doc = "Abort If Condition is False\n\nConditionally aborts program execution based on `will_abort`."]
    ABORTCOND = 0x1,
    #[doc = "Add Integers\n\nAdds `lhs` and `rhs`, producing `out`."]
    ADDINT = 0x4,
    #[doc = "Add Integer with Natural\n\nAdds `lhs` and `rhs`, producing `out`."]
    ADDINTNAT = 0x5,
    #[doc = "Add Naturals\n\nAdds `lhs` and `rhs`, producing `out`."]
    ADDNAT = 0x6,
    #[doc = "Add Natural with Integer\n\nAdds `lhs` and `rhs`, producing `out`."]
    ADDNATINT = 0x7,
    #[doc = "Add Reals\n\nAdds `lhs` and `rhs`, producing `out`."]
    ADDREAL = 0x8,
    #[doc = "Call Procedure\n\nChanges execution to follow the procedure at the provided call address.\nStandard call ABI (that is, the call ABI of Turing/OpenTuring) requires that the call address be pushed before all of the operands."]
    CALL = 0x32,
    #[doc = "Case Of\n\nJumps to a specific branch depending on `selector`.\n`descriptor` points to a case descriptor describing the case bounds, default branch offset, and per-entry branch.\nSuccinctly, it is of the following layout:\n\n| Type     | Name           |\n|----------|----------------|\n| `int4`   | lower_bound    |\n| `int4`   | upper_bound    | \n| `offset` | default_branch |\n| `offset` | arm_0          |\n| `offset` | arm_1          |\n| ...      | ...            |\n| `offset` | arm_n          |\n\nNote that the case descriptor cannot have more than 1000 arm offsets when targeting Turing/OpenTuring interpreters.\n\nAll offsets are relative to the address of the `descriptor` operand."]
    CASE = 0x35,
    #[doc = "Locate Local Slot\n\nLocates the address of a local in the current call frame.\nOffset is computed relative to the start of the local area."]
    LOCATELOCAL = 0x96,
    #[doc = "Locate Temporary Slot\n\nLocates the address of a temporary in the current call frame.\nOffset is computed relative to the start of the temporaries area.\n\nAs the temporaries area is located after the locals area in the call frame, the size of the call frame must also be known."]
    LOCATETEMP = 0x98,
    #[doc = "Jump Forward\n\nAdvances program counter forwards by `offset` bytes.\nOffset is relative to the address of the offset operand."]
    JUMP = 0x89,
    #[doc = "Jump Backward\n\nRetreats program counter backwards by `offset` bytes.\nOffset is relative to the address of the offset operand."]
    JUMPB = 0x8A,
    #[doc = "Begin Procedure\n\n"]
    PROC = 0xBA,
    #[doc = "Push Relocatable Address\n\nPushes a relocatable address with a runtime-determined base address.\n\nThis may be relative to the base address of the local or external code unit section (code, manifest, or global)."]
    PUSHADDR1 = 0xBC,
    #[doc = "Push Literal 0\n\nPushes a literal 0 value onto the operand stack."]
    PUSHVAL0 = 0xC2,
    #[doc = "Push Literal 1\n\nPushes a literal 1 value onto the operand stack."]
    PUSHVAL1 = 0xC3,
    #[doc = "Return From Procedure\n\n"]
    RETURN = 0xCD,
}
#[doc = "32-bit signed integer."]
pub type Int4 = i32;
#[doc = "32-bit unsigned integer."]
pub type Nat4 = u32;
#[doc = "binary32 floating-point number."]
pub type Real4 = f32;
#[doc = "binary64 floating-point number."]
pub type Real8 = f64;
#[doc = "Address-sized signed integer to offset an `addrint` address with.\nAlways a 32-bit integer, and is always less than or equal to 2^31 - 1 and greater than or equal to -2^31.\nAllocations can never exceed the size of an offset, and are thus limited to a maximum of 2^31 - 1 bytes."]
pub type Offset = u32;
#[doc = "Relocatable address that is resolved at runtime.\nThis is an entry within a relocatable patch list, with `link` pointing to the next entry in the list.\nEach distinct relocatable patch list refers to the local code unit sections (code, manifest, and global), as well as to other code units's sections."]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RelocatableOffset {
    #[doc = "Offset to the next relocatable patch entry to fixup."]
    pub link: Offset,
    #[doc = "Offset within the section, relative to the base address."]
    pub offset: Offset,
}
impl RelocatableOffset {
    #[doc = "Size of the type, in bytes."]
    pub fn size(&self) -> usize { 8usize }
}
#[doc = "Pointer-sized unsigned integer referring to a specific location in the execution address space.\nThis is always a 32-bit integer as 64-bit execution address spaces are unsupported."]
pub type Addrint = u32;
#[doc = "The reason for aborting program execution"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u32)]
pub enum AbortReason {
    #[doc = "For conditional `assert` statements"]
    Assert = 1u32,
    #[doc = "For conditional `pre` statements"]
    PreInvariant = 2u32,
    #[doc = "For conditional `post` statements"]
    PostInvariant = 3u32,
    #[doc = "For conditional `invariant` statements in for-loops"]
    ForInvariant = 4u32,
    #[doc = "For conditional `invariant` statements in loops"]
    LoopInvariant = 5u32,
    #[doc = "For conditional `invariant` statements in module initialization"]
    ModuleInvariant = 6u32,
    #[doc = "For conditional class downcast expressions"]
    ClassDowncast = 7u32,
    #[doc = "For unhandled case arms in case statements without a default label"]
    CaseOutOfRange = 8u32,
    #[doc = "For functions that return without producing a result"]
    NoResult = 9u32,
}
impl AbortReason {
    #[doc = "Size of the type, in bytes."]
    pub fn size(&self) -> usize { 4usize }
    pub fn error_code(&self) -> usize {
        match self {
            Self::Assert => 21usize,
            Self::PreInvariant => 16usize,
            Self::PostInvariant => 17usize,
            Self::ForInvariant => 18usize,
            Self::LoopInvariant => 19usize,
            Self::ModuleInvariant => 20usize,
            Self::ClassDowncast => 10000usize,
            Self::CaseOutOfRange => 25usize,
            Self::NoResult => 26usize,
        }
    }
    pub fn message(&self) -> &'static str {
        match self {
            Self::Assert => "Assert condition is false",
            Self::PreInvariant => "Pre condition is false",
            Self::PostInvariant => "Post condition is false",
            Self::ForInvariant => "For-loop invariant is false",
            Self::LoopInvariant => "Loop invariant is false",
            Self::ModuleInvariant => "Module invariant is false",
            Self::ClassDowncast => "Cannot convert pointer to more specific class",
            Self::CaseOutOfRange => "Case selector is out of range",
            Self::NoResult => "Function failed to give a result",
        }
    }
}
