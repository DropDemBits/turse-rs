//! Generated by `xtask codegen turing-bytecode`, do not edit by hand

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u32)]
#[doc = "An opcode for an instruction."]
pub enum Opcode {
    #[doc = "Abort\n\nAlways aborts program execution."]
    ABORT = 0x0,
    #[doc = "Abort If Condition is False\n\nConditionally aborts program execution based on `will_abort`."]
    ABORTCOND = 0x1,
    #[doc = "Add Integers\n\nAdds as `int` values `lhs` and `rhs`, producing `out`."]
    ADDINT = 0x4,
    #[doc = "Add Integer with Natural\n\nAdds `lhs` (as an `int` value) and `rhs` (as a `nat` value), producing `out`."]
    ADDINTNAT = 0x5,
    #[doc = "Add Naturals\n\nAdds as `nat` values `lhs` and `rhs`, producing `out`."]
    ADDNAT = 0x6,
    #[doc = "Add Natural with Integer\n\nAdds `lhs` (as a `nat` value) and `rhs` (as an `int` value), producing `out`."]
    ADDNATINT = 0x7,
    #[doc = "Add Reals\n\nAdds as `real` values `lhs` and `rhs`, producing `out`."]
    ADDREAL = 0x8,
    #[doc = "Call Procedure\n\nChanges execution to follow the procedure at the provided call address.\nStandard call ABI (that is, the call ABI of Turing/OpenTuring) requires that the call address be pushed before all of the operands."]
    CALL = 0x32,
    #[doc = "Case Of\n\nJumps to a specific branch depending on `selector`.\n`descriptor` points to a case descriptor describing the case bounds, default branch offset, and per-entry branch.\nSuccinctly, it is of the following layout:\n\n| Type     | Name           |\n|----------|----------------|\n| `int4`   | lower_bound    |\n| `int4`   | upper_bound    | \n| `offset` | default_branch |\n| `offset` | arm_0          |\n| `offset` | arm_1          |\n| ...      | ...            |\n| `offset` | arm_n          |\n\nNote that the case descriptor cannot have more than 1000 arm offsets when targeting Turing/OpenTuring interpreters.\n\nAll offsets are relative to the address of the `descriptor` operand."]
    CASE = 0x35,
    #[doc = "Compare Equal Addresses\n\nTests as `addrint` values if `lhs` and `rhs` are equal `addrint` values."]
    EQADDR = 0x4E,
    #[doc = "Compare Equal Char(N)\n\nTests as `char(N)` values if `lhs` and `rhs` are equal.\nPerforms a byte-by-byte comparison."]
    EQCHARN = 0x4F,
    #[doc = "Compare Equal Integers\n\nTests as `int` values if `lhs` and `rhs` are equal."]
    EQINT = 0x50,
    #[doc = "Compare Equal Integer with Natural\n\nTests if `lhs` (as an `int` value) and `rhs` (as a `nat` value) are equal values.\nIf `rhs` is greater than `maxint` (`0x7FFFFFFF`), the comparison is always false."]
    EQINTNAT = 0x51,
    #[doc = "Compare Equal Nats\n\nTests as `nat` values if `lhs` and `rhs` are equal."]
    EQNAT = 0x52,
    #[doc = "Compare Equal Reals\n\nTests as `real` values if `lhs` and `rhs` are equal."]
    EQREAL = 0x53,
    #[doc = "Compare Equal Sets\n\nTests as `set` values if `lhs` and `rhs` are equal.\nPerforms a byte-by-byte comparison.\n\n`set_length` determines the size of both sets, as well as determining the set representation.\nSets up to 4 bytes in size are stored in the compact format (as a `set32`), while sets larger than 4 bytes are stored as an indirect array of `set16`s."]
    EQSET = 0x54,
    #[doc = "Compare Equal Strings\n\nTests as `string` values if `lhs` and `rhs` are equal.\nPerforms a byte-by-byte comparison."]
    EQSTR = 0x55,
    #[doc = "Compare Greater or Equal Char(N)\n\nTests as `char(N)` values if `lhs` is greater than or equal to `rhs`.\nPerforms a byte-by-byte comparison."]
    GECHARN = 0x6F,
    #[doc = "Compare Descendant or Same Class\n\n"]
    GECLASS = 0x70,
    #[doc = "Compare Greater or Equal Integers\n\nTests as `int` values if `lhs` is greater than or equal to `rhs`."]
    GEINT = 0x71,
    #[doc = "Compare Greater or Equal Natural with Integer\n\nTests if `lhs` (as an`nat` value) is greater than or equal to `rhs` (as a `nat` value).\nIf `rhs` is greater than `maxint` (`0x7FFFFFFF`), the comparison is always false."]
    GEINTNAT = 0x72,
    #[doc = "Compare Greater or Equal Naturals\n\nTests as `nat` values if `lhs` is greater than or equal to `rhs`."]
    GENAT = 0x73,
    #[doc = "Compare Greater or Equal Integer with Natural\n\nTests if `lhs` (as a `nat` value) is greater than or equal to `rhs` (as an `int` value).\nIf `lhs` is greater than `maxint` (`0x7FFFFFFF`), the comparison is always true."]
    GENATINT = 0x74,
    #[doc = "Compare Greater or Equal Reals\n\nTests as `real` values if `lhs` is greater than or equal to `rhs`."]
    GEREAL = 0x75,
    #[doc = "Compare Greater or Equal Sets\n\nTests as `set` values if `lhs` is a supeset of `rhs` (that is, all elements in `rhs` are contained in `lhs`).\nPerforms a byte-by-byte comparison.\n\n`set_length` determines the size of both sets, as well as determining the set representation.\nSets up to 4 bytes in size are stored in the compact format (as a `set32`), while sets larger than 4 bytes are stored as an indirect array of `set16`s."]
    GESET = 0x76,
    #[doc = "Compare Greater or Equal Strings\n\nTests as `string` values if `lhs` is greater than or equal to `rhs`.\nPerforms a byte-by-byte comparison."]
    GESTR = 0x77,
    #[doc = "Compare Descendant Class\n\n"]
    GTCLASS = 0x7A,
    #[doc = "Compare Less or Equal Char(N)\n\nTests as `char(N)` values if `lhs` is less than or equal to `rhs`.\nPerforms a byte-by-byte comparison."]
    LECHARN = 0x8B,
    #[doc = "Compare Ancestor or Same Class\n\n"]
    LECLASS = 0x8C,
    #[doc = "Compare Less or Equal Integers\n\nTests as `int` values if `lhs` is less than or equal to `rhs`."]
    LEINT = 0x8D,
    #[doc = "Compare Less or Equal Natural with Integer\n\nTests if `lhs` (as an `int` value) is less than or equal to `rhs` (as a `nat` value).\nIf `rhs` is greater than `maxint` (`0x7FFFFFFF`), the comparison is always true."]
    LEINTNAT = 0x8E,
    #[doc = "Compare Less or Equal Naturals\n\nTests as `nat` values if `lhs` is less than or equal to `rhs`."]
    LENAT = 0x8F,
    #[doc = "Compare Less or Equal Integer with Natural\n\nTests if `lhs` (as a `nat` value) is less than or equal to `rhs` (as an `int` value).\nIf `lhs` is greater than `maxint` (`0x7FFFFFFF`), the comparison is always false."]
    LENATINT = 0x90,
    #[doc = "Compare Less or Equal Reals\n\nTests as `real` values if `lhs` is less than or equal to `rhs`."]
    LEREAL = 0x91,
    #[doc = "Compare Less or Equal Sets\n\nTests as `set` values if `lhs` is a subset of `rhs` (that is, all elements in `lhs` are contained in `rhs`).\nPerforms a byte-by-byte comparison.\n\n`set_length` determines the size of both sets, as well as determining the set representation.\nSets up to 4 bytes in size are stored in the compact format (as a `set32`), while sets larger than 4 bytes are stored as an indirect array of `set16`s."]
    LESET = 0x92,
    #[doc = "Compare Less or Equal Strings\n\nTests as `string` values if `lhs` is less than or equal to `rhs`.\nPerforms a byte-by-byte comparison."]
    LESTR = 0x93,
    #[doc = "Jump Forward\n\nAdvances program counter forwards by `offset` bytes.\nOffset is relative to the address of the offset operand."]
    JUMP = 0x89,
    #[doc = "Jump Backward\n\nRetreats program counter backwards by `offset` bytes.\nOffset is relative to the address of the offset operand."]
    JUMPB = 0x8A,
    #[doc = "Locate Local Slot\n\nLocates the address of a local in the current call frame.\nOffset is computed relative to the start of the local area."]
    LOCATELOCAL = 0x96,
    #[doc = "Locate Temporary Slot\n\nLocates the address of a temporary in the current call frame.\nOffset is computed relative to the start of the temporaries area.\n\nAs the temporaries area is located after the locals area in the call frame, the size of the call frame must also be known."]
    LOCATETEMP = 0x98,
    #[doc = "Compare Ancestor Class\n\n"]
    LTCLASS = 0x99,
    #[doc = "Begin Procedure\n\n"]
    PROC = 0xBA,
    #[doc = "Push Address\n\nPushes an absolute address. The address will not be relocated."]
    PUSHADDR = 0xBB,
    #[doc = "Push Relocatable Address\n\nPushes a relocatable address with a runtime-determined base address.\n\nThis may be relative to the base address of the local or external code unit section (code, manifest, or global)."]
    PUSHADDR1 = 0xBC,
    #[doc = "Push Copy of Value\n\nPushes a copy of the top value on the operand stack.\n\nWill only copy `nat4` sized or smaller values."]
    PUSHCOPY = 0xBD,
    #[doc = "Push Literal Integer Value\n\nPushes a literal `int` value onto the operand stack."]
    PUSHINT = 0xBE,
    #[doc = "Push Literal Int1 Value\n\nPushes a literal `int1` value onto the operand stack."]
    PUSHINT1 = 0xBF,
    #[doc = "Push Literal Int2 Value\n\nPushes a literal `int2` value onto the operand stack."]
    PUSHINT2 = 0xC0,
    #[doc = "Push Literal Real Value\n\nPushes a literal `real8` value onto the operand stack."]
    PUSHREAL = 0xC1,
    #[doc = "Push Literal 0\n\nPushes a literal 0 value onto the operand stack."]
    PUSHVAL0 = 0xC2,
    #[doc = "Push Literal 1\n\nPushes a literal 1 value onto the operand stack."]
    PUSHVAL1 = 0xC3,
    #[doc = "Put Characters to Stream\n\nPuts the given value to the provided `stream`.\n\nThe actual number of stack arguments is based on `put_kind`, as different put items have different uses for the arguments."]
    PUT = 0xC4,
    #[doc = "Return From Procedure\n\n"]
    RETURN = 0xCD,
    #[doc = "Increment Line Number\n\nIncrements the line number up by 1.\n\nPrimarily used for debugging, this has no effect on the program state."]
    INCLINENO = 0x7D,
    #[doc = "Set File & Line Number\n\nSets the current execution file number and line number.\n\nPrimarily used for debugging, this has no effect on the program state."]
    SETFILENO = 0xD5,
    #[doc = "Set Line Number\n\nSets the current execution line number, using the same file number.\n\nPrimarily used for debugging, this has no effect on the program state."]
    SETLINENO = 0xD6,
}
#[doc = "8-bit signed integer."]
pub type Int1 = i8;
#[doc = "16-bit signed integer."]
pub type Int2 = i16;
#[doc = "32-bit signed integer.\n\n`0x80000000` is used as a sentinel value in `int` to represent uninitialized `int` variables.\n`int4` values have no such sentinel values."]
pub type Int4 = i32;
#[doc = "16-bit unsigned integer."]
pub type Nat2 = u16;
#[doc = "32-bit unsigned integer.\n\n`0xFFFFFFFF` is used as a sentinel value in `nat` to represent uninitialized `nat` variables.\n`nat4` values have no such sentinel values."]
pub type Nat4 = u32;
#[doc = "binary32 floating-point number."]
pub type Real4 = f32;
#[doc = "binary64 floating-point number."]
pub type Real8 = f64;
#[doc = "Element of a large bitset, storing up to 16 elements.\nSets larger than 4 bytes (32 elements) store the backing bitset as a separate allocation of an array of `set16`s."]
pub type Set16 = u16;
#[doc = "Compact bitset, storing up to 32 elements.\nSets up to 4 bytes in size store the backing bitset inline with the value."]
pub type Set32 = u32;
#[doc = "Address-sized signed integer to offset an `addrint` address with.\nAlways a 32-bit integer, and is always less than or equal to 2^31 - 1 and greater than or equal to -2^31.\nAllocations can never exceed the size of an offset, and are thus limited to a maximum of 2^31 - 1 bytes.\n\n`0xFFFFFFFF` is used as a sentinel value to represent uninitialized `addrint` variables."]
pub type Offset = u32;
#[doc = "Relocatable address that is resolved at runtime.\nThis is an entry within a relocatable patch list, with `link` pointing to the next entry in the list.\nEach distinct relocatable patch list refers to the local code unit sections (code, manifest, and global), as well as to other code units's sections."]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RelocatableOffset {
    #[doc = "Offset to the next relocatable patch entry to fixup."]
    pub link: Offset,
    #[doc = "Offset within the section, relative to the base address."]
    pub offset: Offset,
}
impl RelocatableOffset {
    #[doc = "Size of the type, in bytes."]
    pub fn size(&self) -> usize { 8usize }
}
#[doc = "Pointer-sized unsigned integer referring to a specific location in the execution address space.\nThis is always a 32-bit integer as 64-bit execution address spaces are unsupported."]
pub type Addrint = u32;
#[doc = "The reason for aborting program execution"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u32)]
pub enum AbortReason {
    #[doc = "For conditional `assert` statements."]
    Assert = 1u32,
    #[doc = "For conditional `pre` statements."]
    PreInvariant = 2u32,
    #[doc = "For conditional `post` statements."]
    PostInvariant = 3u32,
    #[doc = "For conditional `invariant` statements in for-loops."]
    ForInvariant = 4u32,
    #[doc = "For conditional `invariant` statements in loops."]
    LoopInvariant = 5u32,
    #[doc = "For conditional `invariant` statements in module initialization."]
    ModuleInvariant = 6u32,
    #[doc = "For conditional class downcast expressions."]
    ClassDowncast = 7u32,
    #[doc = "For unhandled case arms in case statements without a default label."]
    CaseOutOfRange = 8u32,
    #[doc = "For functions that return without producing a result."]
    NoResult = 9u32,
}
impl AbortReason {
    #[doc = "Size of the type, in bytes."]
    pub fn size(&self) -> usize { 4usize }
    pub fn error_code(&self) -> usize {
        match self {
            Self::Assert => 21usize,
            Self::PreInvariant => 16usize,
            Self::PostInvariant => 17usize,
            Self::ForInvariant => 18usize,
            Self::LoopInvariant => 19usize,
            Self::ModuleInvariant => 20usize,
            Self::ClassDowncast => 10000usize,
            Self::CaseOutOfRange => 25usize,
            Self::NoResult => 26usize,
        }
    }
    pub fn message(&self) -> &'static str {
        match self {
            Self::Assert => "Assert condition is false",
            Self::PreInvariant => "Pre condition is false",
            Self::PostInvariant => "Post condition is false",
            Self::ForInvariant => "For-loop invariant is false",
            Self::LoopInvariant => "Loop invariant is false",
            Self::ModuleInvariant => "Module invariant is false",
            Self::ClassDowncast => "Cannot convert pointer to more specific class",
            Self::CaseOutOfRange => "Case selector is out of range",
            Self::NoResult => "Function failed to give a result",
        }
    }
}
#[doc = "Valid put items for **PUT**."]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u32)]
pub enum PutKind {
    #[doc = "Boolean item for putting `boolean` values."]
    Boolean = 0u32,
    #[doc = "Char item for putting `char` values."]
    Char = 1u32,
    #[doc = "CharN item for putting `char(N)` values.\n\n## Note\nThe stack argument ordering is emitted in the opposite order from original Turing, where `width` and `length` are swapped.\nThis uses the ordering from the bytecode executor, which is the ultimate consumer of the bytecode anyways."]
    CharN = 2u32,
    #[doc = "Enum item for putting `enum` types.\n\nPoints to a list of variant names."]
    Enum = 3u32,
    #[doc = "Int item for putting `int` types, with only the width argument."]
    Int = 4u32,
    #[doc = "Int item for putting `int` types, with the width and fractional width arguments."]
    IntFract = 5u32,
    #[doc = "Int item for putting `int` types, with the width, fractional width, and exponent width arguments."]
    IntExp = 6u32,
    #[doc = "Nat item for putting `nat` types, with only the width argument."]
    Nat = 7u32,
    #[doc = "Nat item for putting `nat` types, with the width and fractional width arguments."]
    NatFract = 8u32,
    #[doc = "Nat item for putting `nat` types, with the width, fractional width, and exponent width arguments."]
    NatExp = 9u32,
    #[doc = "Real item for putting `real` types, with only the width argument."]
    Real = 10u32,
    #[doc = "Real item for putting `real` types, with the width and fractional width arguments."]
    RealFract = 11u32,
    #[doc = "Real item for putting `real` types, with the width, fractional width, and exponent width arguments."]
    RealExp = 12u32,
    #[doc = "String item for putting `string` types."]
    String = 13u32,
    #[doc = "Skip item, only putting a newline."]
    Skip = 14u32,
}
impl PutKind {
    #[doc = "Size of the type, in bytes."]
    pub fn size(&self) -> usize { 4usize }
}
#[doc = "Valid get items for **GET**."]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u32)]
pub enum GetKind {
    Skip = 14u32,
}
impl GetKind {
    #[doc = "Size of the type, in bytes."]
    pub fn size(&self) -> usize { 4usize }
}
#[doc = "Standard streams selectable from [**SETSTDSTREAM**].\n\n[**SETSTDSTREAM**](Opcode::SETSTDSTREAM)"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u32)]
pub enum StdStream {
    #[doc = "Standard in stream."]
    Stdin = 1u32,
    #[doc = "Standard out stream."]
    Stdout = 2u32,
}
impl StdStream {
    #[doc = "Size of the type, in bytes."]
    pub fn size(&self) -> usize { 4usize }
    pub fn default_handle(&self) -> isize {
        match self {
            Self::Stdin => -2isize,
            Self::Stdout => -1isize,
        }
    }
}
#[doc = "Stream operations that can be used from [**SETSTREAM**].\n\n[**SETSTREAM**](Opcode::SETSTREAM)"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u32)]
pub enum StreamKind {
    Seek = 0u32,
    Get = 1u32,
    Put = 2u32,
    Read = 3u32,
    Write = 4u32,
}
impl StreamKind {
    #[doc = "Size of the type, in bytes."]
    pub fn size(&self) -> usize { 4usize }
}
#[doc = "Which kind of check is being performed in a **CHKRANGE**."]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u32)]
pub enum CheckKind {
    #[doc = "Range check as part of an assignment."]
    Assign = 0u32,
    #[doc = "Negative or zero char(*) length."]
    AnyChar = 1u32,
    #[doc = "Value passed to `chr` is not in `[0,255]`."]
    Chr = 2u32,
    #[doc = "After an arithmetic operation."]
    IntOverflow = 3u32,
    #[doc = "Range check as part of an assignemt into a range."]
    RangeAssign = 4u32,
    #[doc = "Computation of a for-loop step."]
    LoopStep = 5u32,
    #[doc = "Asserting that `pred` isn't applied on the first element of a sequence."]
    Pred = 6u32,
    #[doc = "Asserting that `succ` isn't applied on the last element of a sequence."]
    Succ = 7u32,
    #[doc = "Asserting that a value is a valid tag for a given union."]
    TagValue = 8u32,
    #[doc = "Range check as part of range parameter passing."]
    ValueParam = 9u32,
}
impl CheckKind {
    #[doc = "Size of the type, in bytes."]
    pub fn size(&self) -> usize { 4usize }
}
