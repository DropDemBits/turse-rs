//! Generated by `xtask codegen turing-bytecode`, do not edit by hand

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u32)]
#[doc = "An opcode for an instruction."]
pub enum Opcode {
    #[doc = "Abort\n\nAlways aborts program execution."]
    ABORT = 0x0,
    #[doc = "Abort If Condition is False\n\nConditionally aborts program execution based on `will_abort`."]
    ABORTCOND = 0x1,
    #[doc = "Add Integers\n\nAdds as `int` values `lhs` and `rhs`, producing `out`."]
    ADDINT = 0x4,
    #[doc = "Add Integer with Natural\n\nAdds `lhs` (as an `int` value) and `rhs` (as a `nat` value), producing `out`."]
    ADDINTNAT = 0x5,
    #[doc = "Add Naturals\n\nAdds as `nat` values `lhs` and `rhs`, producing `out`."]
    ADDNAT = 0x6,
    #[doc = "Add Natural with Integer\n\nAdds `lhs` (as a `nat` value) and `rhs` (as an `int` value), producing `out`."]
    ADDNATINT = 0x7,
    #[doc = "Add Reals\n\nAdds as `real` values `lhs` and `rhs`, producing `out`."]
    ADDREAL = 0x8,
    #[doc = "Bitwise And\n\nApplies a bitwise logical and operation between `lhs` and `rhs`, producing `out`."]
    AND = 0xF,
    #[doc = "Assign Address Value\n\nStores a `value` as an `addrint` value at the provided `dest` address."]
    ASNADDR = 0x11,
    #[doc = "Assign Address Value (Inverted)\n\nStores a `value` as an `addrint` value at the provided `dest` address.\n\nStack operand order corresponds to post-computing the `dest` address."]
    ASNADDRINV = 0x12,
    #[doc = "Assign Integer Value\n\nStores a `value` as an `int` value at the provided `dest` address.\nAsserts that `value` is not `undefint` (`0x8000_0000`)."]
    ASNINT = 0x13,
    #[doc = "Assign Integer Value (Inverted)\n\nStores a `value` as an `int` value at the provided `dest` address.\nAsserts that `value` is not `undefint` (`0x8000_0000`).\n\nStack operand order corresponds to post-computing the `dest` address."]
    ASNINTINV = 0x14,
    #[doc = "Assign Int1 Value\n\nStores a `value` as an `int1` value at the provided `dest` address.\nAsserts that `value` is representable as an `int1` (i.e. it is within the range `[-128..127]`)."]
    ASNINT1 = 0x15,
    #[doc = "Assign Int1 Value (Inverted)\n\nStores a `value` as an `int1` value at the provided `dest` address.\nAsserts that `value` is representable as an `int1` (i.e. it is within the range `[-128..127]`).\n\nStack operand order corresponds to post-computing the `dest` address."]
    ASNINT1INV = 0x16,
    #[doc = "Assign Int2 Value\n\nStores a `value` as an `int2` value at the provided `dest` address.\nAsserts that `value` is representable as an `int2` (i.e. it is within the range `[-32768..32767]`)."]
    ASNINT2 = 0x17,
    #[doc = "Assign Int2 Value (Inverted)\n\nStores a `value` as an `int2` value at the provided `dest` address.\nAsserts that `value` is representable as an `int2` (i.e. it is within the range `[-32768..32767]`).\n\nStack operand order corresponds to post-computing the `dest` address."]
    ASNINT2INV = 0x18,
    #[doc = "Assign Int4 Value\n\nStores a `value` as an `int4` value at the provided `dest` address.\nUnlike [**ASNINT**], this does not perform uninit checking.\n\n[**ASNINT**]: Opcode::ASNINT"]
    ASNINT4 = 0x19,
    #[doc = "Assign Int4 Value (Inverted)\n\nStores a `value` as an `int4` value at the provided `dest` address.\nUnlike [**ASNINTINV**], this does not perform uninit checking.\n\nStack operand order corresponds to post-computing the `dest` address.\n\n[**ASNINTINV**]: Opcode::ASNINTINV"]
    ASNINT4INV = 0x1A,
    #[doc = "Assign Natural Value\n\nStores a `value` as a `nat` value at the provided `dest` address.\nAsserts that `value` is not `undefnat` (`0xFFFF_FFFF`)."]
    ASNNAT = 0x1B,
    #[doc = "Assign Natural Value (Inverted)\n\nStores a `value` as an `int` value at the provided `dest` address.\nAsserts that `value` is not `undefnat` (`0xFFFF_FFFF`).\n\nStack operand order corresponds to post-computing the `dest` address."]
    ASNNATINV = 0x1C,
    #[doc = "Assign Nat1 Value\n\nStores a `value` as a `nat1` value at the provided `dest` address.\nAsserts that `value` is representable as a `nat1` (i.e. it is within the range `[0..255]`)."]
    ASNNAT1 = 0x1D,
    #[doc = "Assign Nat1 Value (Inverted)\n\nStores a `value` as a `nat1` value at the provided `dest` address.\nAsserts that `value` is representable as a `nat1` (i.e. it is within the range `[0..255]`).\n\nStack operand order corresponds to post-computing the `dest` address."]
    ASNNAT1INV = 0x1E,
    #[doc = "Assign Int2 Value\n\nStores a `value` as a `nat2` value at the provided `dest` address.\nAsserts that `value` is representable as a `nat2` (i.e. it is within the range `[0..65535]`)."]
    ASNNAT2 = 0x1F,
    #[doc = "Assign Int2 Value (Inverted)\n\nStores a `value` as an `nat2` value at the provided `dest` address.\nAsserts that `value` is representable as an `nat2` (i.e. it is within the range `[0..65535]`).\n\nStack operand order corresponds to post-computing the `dest` address."]
    ASNNAT2INV = 0x20,
    #[doc = "Assign Nat4 Value\n\nStores a `value` as a `nat4` value at the provided `dest` address.\nUnlike [**ASNNAT**], this does not perform uninit checking.\n\n[**ASNNAT**]: Opcode::ASNNAT"]
    ASNNAT4 = 0x21,
    #[doc = "Assign Nat4 Value (Inverted)\n\nStores a `value` as an `nat4` value at the provided `dest` address.\nUnlike [**ASNNATINV**], this does not perform uninit checking.\n\nStack operand order corresponds to post-computing the `dest` address.\n\n[**ASNNATINV**]: Opcode::ASNNATINV"]
    ASNNAT4INV = 0x22,
    #[doc = "Assign Non-Scalar Value\n\nCopies `length` bytes from `src` to `dest`."]
    ASNNONSCALAR = 0x23,
    #[doc = "Assign Non-Scalar Value (Inverted)\n\nCopies `length` bytes from `src` to `dest`.\n\nStack operand order corresponds to post-computing the `dest` address."]
    ASNNONSCALARINV = 0x24,
    #[doc = "Assign Checked Pointer Value\n\nCopies the address stored in pointer descriptor information from `src` to `dest`'s pointer descriptor.\nIf `src` does not point to a `nil` (`0x0`) address, additional metadata is copied to `dest` from the pointed-to heap allocation (e.g. the generation cookie)."]
    ASNPTR = 0x25,
    #[doc = "Assign Checked Pointer Value (Inverted)\n\nCopies the address stored in pointer descriptor information from `src` to `dest`'s pointer descriptor.\nIf `src` does not point to a `nil` (`0x0`) address, additional metadata is copied to `dest` from the pointed-to heap allocation (e.g. the generation cookie)."]
    ASNPTRINV = 0x26,
    #[doc = "Assign Real Value\n\nStores a `value` as a `real` value at the provided `dest` address.\nDoes not perform uninit checking."]
    ASNREAL = 0x27,
    #[doc = "Assign Real Value (Inverted)\n\nStores a `value` as a `real` value at the provided `dest` address.\nDoes not perform uninit checking.\n\nStack operand order corresponds to post-computing the `dest` address."]
    ASNREALINV = 0x28,
    #[doc = "Assign Real4 Value\n\nStores a `value` as a `real4` value at the provided `dest` address.\nApplies a narrowing cast to `real8` to convert the value into the equivalent `real4` representation."]
    ASNREAL4 = 0x29,
    #[doc = "Assign Real4 Value (Inverted)\n\nStores a `value` as a `real4` value at the provided `dest` address.\nApplies a narrowing cast to `real8` to convert the value into the equivalent `real4` representation.\n\nStack operand order corresponds to post-computing the `dest` address."]
    ASNREAL4INV = 0x2A,
    #[doc = "Assign Real8 Value\n\nStores a `value` as a `real8` value at the provided `dest` address.\nDoes not perform uninit checking."]
    ASNREAL8 = 0x2B,
    #[doc = "Assign Real8 Value (Inverted)\n\nStores a `value` as a `real8` value at the provided `dest` address.\nDoes not perform uninit checking.\n\nStack operand order corresponds to post-computing the `dest` address."]
    ASNREAL8INV = 0x2C,
    #[doc = "Assign String Value\n\nCopies up to `max_length` string bytes from `src` to `dest`.\nAsserts that the string byte length of `src` is less than or equal to `max_length`.\nDoes not perform uninit checking."]
    ASNSTR = 0x2D,
    #[doc = "Assign String Value (Inverted)\n\nCopies up to `max_length` string bytes from `src` to `dest`.\nAsserts that the string byte length of `src` is less than or equal to `max_length`.\nDoes not perform uninit checking.\n\nStack operand order corresponds to post-computing the `dest` address."]
    ASNSTRINV = 0x2E,
    #[doc = "Call Procedure\n\nChanges execution to follow the procedure at the provided call address.\nStandard call ABI (that is, the call ABI of Turing/OpenTuring) requires that the call address be pushed before all of the operands."]
    CALL = 0x32,
    #[doc = "Case Of\n\nJumps to a specific branch depending on `selector`.\n`descriptor` points to a case descriptor describing the case bounds, default branch offset, and per-entry branch.\nSuccinctly, it is of the following layout:\n\n| Type     | Name           |\n|----------|----------------|\n| `int4`   | lower_bound    |\n| `int4`   | upper_bound    | \n| `offset` | default_branch |\n| `offset` | arm_0          |\n| `offset` | arm_1          |\n| ...      | ...            |\n| `offset` | arm_n          |\n\nNote that the case descriptor cannot have more than 1000 arm offsets when targeting Turing/OpenTuring interpreters.\n\nAll offsets are relative to the address of the `descriptor` operand."]
    CASE = 0x35,
    #[doc = "Convert Char to Char(N)\n\nConverts `value` as a `char` into a `char(N)` stored at `out`."]
    CHARTOCSTR = 0x39,
    #[doc = "Converts a `char` value into a `string` value (`value` followed by a nul terminator)."]
    CHARTOSTR = 0x3A,
    #[doc = "Converts a `char` value into a `string` value (`value` followed by a nul terminator).\nPreserves the existing right-hand side `char` value."]
    CHARTOSTRLEFT = 0x3B,
    #[doc = "Check Char(N) Length\n\nAsserts that `length` is equal to `expected_length`."]
    CHKCHRSTRSIZE = 0x3C,
    #[doc = "Check Value in Range\n\nAsserts that the value at `stack_offset` is within the range `[min..max]` (inclusive range).     \n\nRaises an exception dependent on `check_type` if the value is outside of the range."]
    CHKRANGE = 0x3E,
    #[doc = "Check String Length\n\nAsserts that the byte length of `value` is equal to `expected_length`."]
    CHKSTRSIZE = 0x40,
    #[doc = "Convert Char(N) to Char\n\nConverts a `char(N)` value of byte length `length` into a `char` value by extracting the first `char`.\nAsserts that `length` is 1."]
    CSTRTOCHAR = 0x43,
    #[doc = "Convert Char(N) to String\n\nConverts a `char(N)` value into the equivalent `string` value.\nAssumes that `dest` is large enough to store the resultant `string` value."]
    CSTRTOSTR = 0x44,
    #[doc = "Convert Left-Hand Side Char(N) to String\n\nConverts a `char(N)` value into the equivalent `string` value, preserving the existing right-hand side `string` value.\nAssumes that `dest` is large enough to store the resultant `string` value."]
    CSTRTOSTRLEFT = 0x45,
    #[doc = "Divide Integers\n\nDivides as `int` values `lhs` and `rhs`, producing `out`."]
    DIVINT = 0x48,
    #[doc = "Divide Naturals\n\nDivides as `nat` values `lhs` and `rhs`, producing `out`."]
    DIVNAT = 0x49,
    #[doc = "Integer Divide Reals\n\nInteger divides as `real` values `lhs` and `rhs`, producing `out` after truncating to an `int` value.\nAsserts that `out` when converted to an `int` is still representable (that is, it is not outside of the range of possible `int` values)."]
    DIVREAL = 0x4A,
    #[doc = "Compare Equal Addresses\n\nTests as `addrint` values if `lhs` and `rhs` are equal `addrint` values."]
    EQADDR = 0x4E,
    #[doc = "Compare Equal Char(N)\n\nTests as `char(N)` values if `lhs` and `rhs` are equal.\nPerforms a byte-by-byte comparison."]
    EQCHARN = 0x4F,
    #[doc = "Compare Equal Integers\n\nTests as `int` values if `lhs` and `rhs` are equal."]
    EQINT = 0x50,
    #[doc = "Compare Equal Integer with Natural\n\nTests if `lhs` (as an `int` value) and `rhs` (as a `nat` value) are equal values.\nIf `rhs` is greater than `maxint` (`0x7FFF_FFFF`), the comparison is always false."]
    EQINTNAT = 0x51,
    #[doc = "Compare Equal Nats\n\nTests as `nat` values if `lhs` and `rhs` are equal."]
    EQNAT = 0x52,
    #[doc = "Compare Equal Reals\n\nTests as `real` values if `lhs` and `rhs` are equal."]
    EQREAL = 0x53,
    #[doc = "Compare Equal Sets\n\nTests as `set` values if `lhs` and `rhs` are equal.\nPerforms a byte-by-byte comparison.\n\n`set_length` determines the size of both sets, as well as determining the set representation.\nSets up to 4 bytes in size are stored in the compact format (as a `set32`), while sets larger than 4 bytes are stored as an indirect array of `set16`s."]
    EQSET = 0x54,
    #[doc = "Compare Equal Strings\n\nTests as `string` values if `lhs` and `rhs` are equal.\nPerforms a byte-by-byte comparison."]
    EQSTR = 0x55,
    #[doc = "Exponentiate Integers\n\nRaises `lhs` to the power of `rhs` as `int` values, producing `out`."]
    EXPINTINT = 0x56,
    #[doc = "Exponentiate Real with Integer\n\nRaises `lhs` (as a `real` value) to the power of `rhs` (as an `int` value), producing `out`."]
    EXPREALINT = 0x57,
    #[doc = "Exponentiate Reals\n\nRaises `lhs` to the power of `rhs` as `real` values, producing `out`."]
    EXPREALREAL = 0x58,
    #[doc = "Fetch Address Value\n\nFetches an `addrint` value from `addr`.\nAsserts that the loaded value is not `undefaddr` (`0xFFFF_FFFF`)."]
    FETCHADDR = 0x59,
    #[doc = "Fetch Boolean Value\n\nFetches a `boolean` value from `addr`, performing a 1-byte load.\nAsserts that the loaded value is not `undefbool` (`0xFF`)."]
    FETCHBOOL = 0x5A,
    #[doc = "Fetch Integer Value\n\nFetches an `int` value from `addr`, performing a 4-byte load.\nAsserts that the loaded value is not `undefint` (`0x8000_0000`)."]
    FETCHINT = 0x5B,
    #[doc = "Fetch Int1 Value\n\nFetches an `int1` value from `addr`, performing a 1-byte load.\nCoerces the loaded `value` into an `int4` value."]
    FETCHINT1 = 0x5C,
    #[doc = "Fetch Int2 Value\n\nFetches an `int2` value from `addr`, performing a 2-byte load.\nCoerces the loaded `value` into an `int4` value."]
    FETCHINT2 = 0x5D,
    #[doc = "Fetch Int4 Value\n\nFetches an `int4` value from `addr`, performing a 4-byte load.\nUnlike [**FETCHINT**], this does not perform uninit checking.\n\n[**FETCHINT**]: Opcode::FETCHINT"]
    FETCHINT4 = 0x5E,
    #[doc = "Fetch Natural Value\n\nFetches a `nat` value from `addr`, performing a 4-byte load.\nAsserts that the loaded value is not `undefnat` (`0xFFFF_FFFF`)."]
    FETCHNAT = 0x5F,
    #[doc = "Fetch Nat1 Value\n\nFetches a `nat1` value from `addr`, performing a 1-byte load.\nCoerces the loaded `value` into a `nat4` value."]
    FETCHNAT1 = 0x60,
    #[doc = "Fetch Nat2 Value\n\nFetches a `nat2` value from `addr`, performing a 2-byte load.\nCoerces the loaded `value` into a `nat4` value."]
    FETCHNAT2 = 0x61,
    #[doc = "Fetch Nat4 Value\n\nFetches a `nat4` value from `addr`, performing a 4-byte load.\nUnlike [**FETCHNAT**], this does not perform uninit checking.\n\n[**FETCHNAT**]: Opcode::FETCHNAT"]
    FETCHNAT4 = 0x62,
    #[doc = "Fetch Checked Pointer Value\n\nFetches an `addrint` value from `addr`, performing a 4-byte load.\nAsserts that the loaded value is not `undefaddr` (`0xFFFF_FFFF`), and that the checked pointer's generation cookie matches the pointed-to allocation's generation cookie."]
    FETCHPTR = 0x63,
    #[doc = "Fetch Real Value\n\nFetches a `real` value from `addr`, performing an 8-byte load.\nAsserts that the loaded value is not `undefreal` (`0x8000_0000_8000_0000`)."]
    FETCHREAL = 0x64,
    #[doc = "Fetch Real4 Value\n\nFetches a `real4` value from `addr`, performing a 4-byte load.\nCoerces the loaded `value` into a `real8` value."]
    FETCHREAL4 = 0x65,
    #[doc = "Fetch Real8 Value\n\nFetches a `real8` value from `addr`, performing an 8-byte load.\nUnlike [**FETCHREAL**], this does not perform uninit checking.\n\n[**FETCHREAL**]: Opcode::FETCHREAL"]
    FETCHREAL8 = 0x66,
    #[doc = "Fetch Compact Set Value\n\nFetches a compact set value from `addr`, performing a `set_length`-byte load.\n\nAsserts that the loaded value is not:\n\n- `undefset8` (`0x80`) when `set_length` is 1.\n- `undefset16` (`0x8000`) when `set_length` is 2.\n- `undefset32` (`0x8000_000`) when `set_length` is 4.\n\nCoerces the loaded `value` into a `set32` value."]
    FETCHSET = 0x67,
    #[doc = "Fetch String Value\n\nAsserts that the string at `addr` is an initialized string, i.e. the first byte is not `undefchar` (`0x80`)."]
    FETCHSTR = 0x68,
    #[doc = "Begin For-Loop\n\n"]
    FOR = 0x6A,
    #[doc = "End For-Loop\n\n"]
    ENDFOR = 0x4C,
    #[doc = "Compare Greater or Equal Char(N)\n\nTests as `char(N)` values if `lhs` is greater than or equal to `rhs`.\nPerforms a byte-by-byte comparison."]
    GECHARN = 0x6F,
    #[doc = "Compare Descendant or Same Class\n\n"]
    GECLASS = 0x70,
    #[doc = "Compare Greater or Equal Integers\n\nTests as `int` values if `lhs` is greater than or equal to `rhs`."]
    GEINT = 0x71,
    #[doc = "Compare Greater or Equal Natural with Integer\n\nTests if `lhs` (as an`nat` value) is greater than or equal to `rhs` (as a `nat` value).\nIf `rhs` is greater than `maxint` (`0x7FFF_FFFF`), the comparison is always false."]
    GEINTNAT = 0x72,
    #[doc = "Compare Greater or Equal Naturals\n\nTests as `nat` values if `lhs` is greater than or equal to `rhs`."]
    GENAT = 0x73,
    #[doc = "Compare Greater or Equal Integer with Natural\n\nTests if `lhs` (as a `nat` value) is greater than or equal to `rhs` (as an `int` value).\nIf `lhs` is greater than `maxint` (`0x7FFF_FFFF`), the comparison is always true."]
    GENATINT = 0x74,
    #[doc = "Compare Greater or Equal Reals\n\nTests as `real` values if `lhs` is greater than or equal to `rhs`."]
    GEREAL = 0x75,
    #[doc = "Compare Greater or Equal Sets\n\nTests as `set` values if `lhs` is a supeset of `rhs` (that is, all elements in `rhs` are contained in `lhs`).\nPerforms a byte-by-byte comparison.\n\n`set_length` determines the size of both sets, as well as determining the set representation.\nSets up to 4 bytes in size are stored in the compact format (as a `set32`), while sets larger than 4 bytes are stored as an indirect array of `set16`s."]
    GESET = 0x76,
    #[doc = "Compare Greater or Equal Strings\n\nTests as `string` values if `lhs` is greater than or equal to `rhs`.\nPerforms a byte-by-byte comparison."]
    GESTR = 0x77,
    #[doc = "Get Characters from Stream\n\nGets the given value from the provided `stream` based on interpreting the stream data as characters.\n\nThe actual number of stack arguments is based on `get_kind`, as different get items have different uses for the arguments.\n`get_kind` is also a variably encoded operand, based on interpreting the first `int4` as the tag value."]
    GET = 0x78,
    #[doc = "Compare Descendant Class\n\n"]
    GTCLASS = 0x7A,
    #[doc = "Branch If Zero\n\nBranches execution if `test` is zero (i.e. false)."]
    IF = 0x7B,
    #[doc = "Increment Stack Pointer\n\nIncrements the stack pointer by `size` bytes.\nEquivalent to repeatedly popping values off of the stack."]
    INCSP = 0x7E,
    #[doc = "Infix And\n\nBranches execution if `value` is zero (i.e. false), otherwise leaves `value` on the stack.\nThis is equivalent to the short-circuiting infix boolean `and` operator."]
    INFIXAND = 0x7F,
    #[doc = "Infix Or\n\nBranches execution if `value` is non-zero (i.e. true), otherwise leaves `value` on the stack.\nThis is equivalent to the short-circuiting infix boolean `or` operator."]
    INFIXOR = 0x80,
    #[doc = "Convert Integer to Real\n\nConverts an `int` value into a `real` value."]
    INTREAL = 0x85,
    #[doc = "Convert Left-Hand Side Integer to Real\n\nConverts an `int` value into a `real` value, preserving the existing right-hand side value."]
    INTREALLEFT = 0x86,
    #[doc = "Compare Less or Equal Char(N)\n\nTests as `char(N)` values if `lhs` is less than or equal to `rhs`.\nPerforms a byte-by-byte comparison."]
    LECHARN = 0x8B,
    #[doc = "Compare Ancestor or Same Class\n\n"]
    LECLASS = 0x8C,
    #[doc = "Compare Less or Equal Integers\n\nTests as `int` values if `lhs` is less than or equal to `rhs`."]
    LEINT = 0x8D,
    #[doc = "Compare Less or Equal Natural with Integer\n\nTests if `lhs` (as an `int` value) is less than or equal to `rhs` (as a `nat` value).\nIf `rhs` is greater than `maxint` (`0x7FFF_FFFF`), the comparison is always true."]
    LEINTNAT = 0x8E,
    #[doc = "Compare Less or Equal Naturals\n\nTests as `nat` values if `lhs` is less than or equal to `rhs`."]
    LENAT = 0x8F,
    #[doc = "Compare Less or Equal Integer with Natural\n\nTests if `lhs` (as a `nat` value) is less than or equal to `rhs` (as an `int` value).\nIf `lhs` is greater than `maxint` (`0x7FFF_FFFF`), the comparison is always false."]
    LENATINT = 0x90,
    #[doc = "Compare Less or Equal Reals\n\nTests as `real` values if `lhs` is less than or equal to `rhs`."]
    LEREAL = 0x91,
    #[doc = "Compare Less or Equal Sets\n\nTests as `set` values if `lhs` is a subset of `rhs` (that is, all elements in `lhs` are contained in `rhs`).\nPerforms a byte-by-byte comparison.\n\n`set_length` determines the size of both sets, as well as determining the set representation.\nSets up to 4 bytes in size are stored in the compact format (as a `set32`), while sets larger than 4 bytes are stored as an indirect array of `set16`s."]
    LESET = 0x92,
    #[doc = "Compare Less or Equal Strings\n\nTests as `string` values if `lhs` is less than or equal to `rhs`.\nPerforms a byte-by-byte comparison."]
    LESTR = 0x93,
    #[doc = "Jump Forward\n\nAdvances program counter forwards by `offset` bytes.\nOffset is relative to the address of the offset operand."]
    JUMP = 0x89,
    #[doc = "Jump Backward\n\nRetreats program counter backwards by `offset` bytes.\nOffset is relative to the address of the offset operand."]
    JUMPB = 0x8A,
    #[doc = "Locate Local Slot\n\nLocates the address of a local in the current call frame.\nOffset is computed relative to the start of the local area."]
    LOCATELOCAL = 0x96,
    #[doc = "Locate Parameter\n\nLocates the address of a passed-in parameter in the current call frame.\nOffset is computed relative to the start of the call frame."]
    LOCATEPARM = 0x97,
    #[doc = "Locate Temporary Slot\n\nLocates the address of a temporary in the current call frame.\nOffset is computed relative to the start of the temporaries area.\n\nAs the temporaries area is located after the locals area in the call frame, the size of the call frame must also be known."]
    LOCATETEMP = 0x98,
    #[doc = "Compare Ancestor Class\n\n"]
    LTCLASS = 0x99,
    #[doc = "Modulus of Integers\n\nComputes the modulus (with floored division) of `lhs` and `rhs` as `int` values, producing `out`."]
    MODINT = 0xA0,
    #[doc = "Modulus of Naturals\n\nComputes the modulus (with floored division) of `lhs` and `rhs` as `nat` values, producing `out`."]
    MODNAT = 0xA1,
    #[doc = "Integer Modulus of Reals\n\nComputes the modulus (with floored division) of `lhs` and `rhs` as `real` values, producing `out`.\nAsserts that the division of `lhs` and `rhs`, when converted to an `int`, is still representable (that is, it is not outside of the range of possible `int` values)."]
    MODREAL = 0xA2,
    #[doc = "Multiply Integers\n\nMultiplies as `int` values `lhs` and `rhs`, producing `out`."]
    MULINT = 0xA5,
    #[doc = "Multiply Naturals\n\nMultiplies as `nat` values `lhs` and `rhs`, producing `out`."]
    MULNAT = 0xA6,
    #[doc = "Multiply Reals\n\nMultiplies as `real` values `lhs` and `rhs`, producing `out`."]
    MULREAL = 0xA7,
    #[doc = "Intersection of Sets\n\nComputes as `set` values the set intersection of `lhs` and `rhs`, producing `out`.\n\n`set_length` determines the size of both sets, as well as determining the set representation.\nSets up to 4 bytes in size are stored in the compact format (as a `set32`), while sets larger than 4 bytes are stored as an indirect array of `set16`s."]
    MULSET = 0xA8,
    #[doc = "Convert Natural to Real\n\nConverts a `nat` value into a `real` value."]
    NATREAL = 0xA9,
    #[doc = "Convert Left-Hand Side Natural to Real\n\nConverts a `nat` value into a `real` value, preserving the existing right-hand side value."]
    NATREALLEFT = 0xAA,
    #[doc = "Negate Integer\n\nFlips the sign of `value` as an `int`, as if it were multiplied by -1.\n\n(throws) If `value` is less than `minint` (`-0x7FFFFFFF`) as there are no equivalent positive values."]
    NEGINT = 0xAC,
    #[doc = "Negate Real\n\nFlips the sign of `value` as a `real`, as if it were multiplied by -1.\n\n(throws) If `value` is less than `minint` (`-0x7FFFFFFF`) as there are no equivalent positive values."]
    NEGREAL = 0xAD,
    #[doc = "Boolean Not\n\nApplies a boolean not operation on `value`, by only flipping the first bit.\nFor a bitwise logical not, a [**XOR**] instruction with a 0xFFFFFFFF constant should be used. \n\n[**XOR**]: Opcode::XOR"]
    NOT = 0xB2,
    #[doc = "Bitwise Or\n\nApplies a bitwise logical or operation between `lhs` and `rhs`, producing `out`."]
    OR = 0xB6,
    #[doc = "Begin Procedure\n\n"]
    PROC = 0xBA,
    #[doc = "Push Address\n\nPushes an absolute address. The address will not be relocated."]
    PUSHADDR = 0xBB,
    #[doc = "Push Relocatable Address\n\nPushes a relocatable address with a runtime-determined base address.\n\nThis may be relative to the base address of the local or external code unit section (code, manifest, or global)."]
    PUSHADDR1 = 0xBC,
    #[doc = "Push Copy of Value\n\nPushes a copy of the top value on the operand stack.\n\nWill only copy `nat4` sized or smaller values."]
    PUSHCOPY = 0xBD,
    #[doc = "Push Literal Integer Value\n\nPushes a literal `int` value onto the operand stack."]
    PUSHINT = 0xBE,
    #[doc = "Push Literal Int1 Value\n\nPushes a literal `int1` value onto the operand stack."]
    PUSHINT1 = 0xBF,
    #[doc = "Push Literal Int2 Value\n\nPushes a literal `int2` value onto the operand stack."]
    PUSHINT2 = 0xC0,
    #[doc = "Push Literal Real Value\n\nPushes a literal `real8` value onto the operand stack."]
    PUSHREAL = 0xC1,
    #[doc = "Push Literal 0\n\nPushes a literal 0 value onto the operand stack."]
    PUSHVAL0 = 0xC2,
    #[doc = "Push Literal 1\n\nPushes a literal 1 value onto the operand stack."]
    PUSHVAL1 = 0xC3,
    #[doc = "Put Characters to Stream\n\nPuts the given value to the provided `stream`.\n\nThe actual number of stack arguments is based on `put_kind`, as different put items have different uses for the arguments."]
    PUT = 0xC4,
    #[doc = "Divide Reals\n\nDivides as `real` values `lhs` and `rhs`, producing `out`."]
    REALDIVIDE = 0xC7,
    #[doc = "Remainder of Integers\n\nComputes the remainder of dividing `lhs` and `rhs` as `int` values."]
    REMINT = 0xC8,
    #[doc = "Integer Remainder of Reals\n\nComputes the integer remainder of dividing `lhs` and `rhs` as `real` values.\nAsserts that the division of `lhs` and `rhs`, when converted to an `int`, is still representable (that is, it is not outside of the range of possible `int` values)."]
    REMREAL = 0xC9,
    #[doc = "Return From Procedure\n\n"]
    RETURN = 0xCD,
    #[doc = "Increment Line Number\n\nIncrements the line number up by 1.\n\nPrimarily used for debugging, this has no effect on the program state."]
    INCLINENO = 0x7D,
    #[doc = "Set File & Line Number\n\nSets the current execution file number and line number.\n\nPrimarily used for debugging, this has no effect on the program state."]
    SETFILENO = 0xD5,
    #[doc = "Set Line Number\n\nSets the current execution line number, using the same file number.\n\nPrimarily used for debugging, this has no effect on the program state."]
    SETLINENO = 0xD6,
    #[doc = "Set Standard I/O Stream\n\nRetrieves the standard I/O handle for `kind` and stores it in `dest`.\nDepending on the I/O redirection settings, this may differ from the standard stream handle numbers."]
    SETSTDSTREAM = 0xD8,
    #[doc = "Set Stream Information\n\nPrepares for future stream operations on `stream_handle`, setting up the `stream_status` and opening the stream if necessary.\n`kind` indicates what stream operation to open the stream for if the stream is not open yet.\n\nAsserts that `stream_handle` is less than or equal to `maxstreamno` and greater than or equal to `stdoutstream` (`-2`)."]
    SETSTREAM = 0xD9,
    #[doc = "Arithmetic Shift Left\n\nApplies an arithmetic left bit-shift on `value`.\nAsserts that the computed value is representable as a `nat4`."]
    SHL = 0xDA,
    #[doc = "Arithmetic Shift Right\n\nApplies an arithmetic right bit-shift on `value` by copying empty positions with the sign bit."]
    SHR = 0xDB,
    #[doc = "Convert String to Char\n\nExtracts a single `char` value from the beginning of the `string` at `value`."]
    STRTOCHAR = 0xE1,
    #[doc = "Subtract Integers\n\nSubtracts as `int` values `lhs` and `rhs`, producing `out`."]
    SUBINT = 0xE2,
    #[doc = "Subtract Integer with Natural\n\nSubtracts `lhs` (as an `int` value) and `rhs` (as a `nat` value), producing `out`."]
    SUBINTNAT = 0xE3,
    #[doc = "Subtract Naturals\n\nSubtracts as `nat` values `lhs` and `rhs`, producing `out`."]
    SUBNAT = 0xE4,
    #[doc = "Subtract Natural with Integer\n\nSubtracts `lhs` (as a `nat` value) and `rhs` (as an `int` value), producing `out`."]
    SUBNATINT = 0xE5,
    #[doc = "Subtract Reals\n\nSubtracts as `real` values `lhs` and `rhs`, producing `out`."]
    SUBREAL = 0xE6,
    #[doc = "Mark Uninitialized Address\n\nStores `undefaddr` (`0xFFFF_FFFF`) to `dest`."]
    UNINITADDR = 0xF0,
    #[doc = "Mark Uninitialized Boolean\n\nStores `undefbool` (`0xFF`) to `dest`."]
    UNINITBOOLEAN = 0xF1,
    #[doc = "Mark Uninitialized Integer\n\nStores `undefint` (`0x8000_0000`) to `dest`."]
    UNINITINT = 0xF2,
    #[doc = "Mark Uninitialized Natural\n\nStores `undefnat` (`0xFFFF_FFFF`) to `dest`."]
    UNINITNAT = 0xF3,
    #[doc = "Mark Uninitialized Real\n\nStores `undefreal` (`0x8000_0000_8000_0000`) to `dest`."]
    UNINITREAL = 0xF4,
    #[doc = "Mark Uninitialized String\n\nStores an `undefchar` (`0x80`) followed by a nul terminator byte (`0x00`) to `dest`."]
    UNINITSTR = 0xF5,
    #[doc = "Bitwise Exclusive-Or\n\nApplies a bitwise logical xor operation between `lhs` and `rhs`, producing `out`."]
    XOR = 0xFA,
}
#[doc = "All named recoverable exceptions that can be thrown during program execution."]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u32)]
pub enum QuitException {
    TagOutOfRange = 14u32,
    AssignmentOutOfRange = 15u32,
    ParameterOutOfRange = 22u32,
    StringParameterTooLong = 23u32,
    ResultOutOfRange = 24u32,
    CaseSelectorOutOfRange = 25u32,
    FunctionNoResult = 26u32,
    DivmodByZero = 33u32,
    StringValueTooLong = 35u32,
    PredOfFirst = 38u32,
    SuccOfLast = 39u32,
    CharAssignedToDynChar = 42u32,
    UninitValue = 45u32,
    IntegerOverflow = 50u32,
    RealOverflow = 51u32,
    RealUnderflow = 52u32,
    IntegerPowNegative = 96u32,
    NegativePowReal = 97u32,
    ZeroPowNegative = 98u32,
    ZeroPowZero = 99u32,
}
impl QuitException {
    #[doc = "Fixed (i.e. non-dynamic) size of the type, in bytes."]
    pub const fn fixed_size() -> usize { 4usize }
    #[doc = "Size of the type, in bytes."]
    pub fn size(&self) -> usize { 4usize }
}
#[doc = "8-bit signed integer."]
pub type Int1 = i8;
#[doc = "16-bit signed integer."]
pub type Int2 = i16;
#[doc = "32-bit signed integer.\n\n`0x80000000` is used as the `undefint` sentinel value in `int` to represent uninitialized `int` variables.\n`int4` values have no such sentinel values."]
pub type Int4 = i32;
#[doc = "16-bit unsigned integer."]
pub type Nat2 = u16;
#[doc = "32-bit unsigned integer.\n\n`0xFFFFFFFF` is used as the `undefnat` sentinel value in `nat` to represent uninitialized `nat` variables.\n`nat4` values have no such sentinel values."]
pub type Nat4 = u32;
#[doc = "binary32 floating-point number."]
pub type Real4 = f32;
#[doc = "binary64 floating-point number."]
pub type Real8 = f64;
#[doc = "Element of a large bitset, storing up to 16 elements.\n\nSets larger than 4 bytes (32 elements) store the backing bitset as a separate allocation of an array of `set16`s."]
pub type Set16 = u16;
#[doc = "Compact bitset, storing up to 32 elements.\n\nSets up to 4 bytes in size store the backing bitset inline with the value."]
pub type Set32 = u32;
#[doc = "Address-sized signed integer to offset an `addrint` address with.\n\nAlways a 32-bit integer, and is always less than or equal to 2^31 - 1 and greater than or equal to -2^31.\nAllocations can never exceed the size of an offset, and are thus limited to a maximum of 2^31 - 1 bytes.\n\n`0xFFFFFFFF` is used as a sentinel value to represent uninitialized `addrint` variables."]
pub type Offset = u32;
#[doc = "Relocatable address that is resolved at runtime.\n\nThis is an entry within a relocatable patch list, with `link` pointing to the next entry in the list.\nEach distinct relocatable patch list refers to the local code unit sections (code, manifest, and global), as well as to other code units's sections."]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct RelocatableOffset {
    #[doc = "Offset to the next relocatable patch entry to fixup."]
    pub link: Offset,
    #[doc = "Offset within the section, relative to the base address."]
    pub offset: Offset,
}
impl RelocatableOffset {
    #[doc = "Fixed (i.e. non-dynamic) size of the type, in bytes."]
    pub const fn fixed_size() -> usize { 8usize }
    #[doc = "Size of the type, in bytes."]
    pub fn size(&self) -> usize { 8usize }
}
#[doc = "Pointer-sized unsigned integer referring to a specific location in the execution address space.\n\nThis is always a 32-bit integer as 64-bit execution address spaces are unsupported."]
pub type Addrint = u32;
#[doc = "The reason for aborting program execution"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u32)]
pub enum AbortReason {
    #[doc = "For conditional `assert` statements."]
    Assert = 1u32,
    #[doc = "For conditional `pre` statements."]
    PreInvariant = 2u32,
    #[doc = "For conditional `post` statements."]
    PostInvariant = 3u32,
    #[doc = "For conditional `invariant` statements in for-loops."]
    ForInvariant = 4u32,
    #[doc = "For conditional `invariant` statements in loops."]
    LoopInvariant = 5u32,
    #[doc = "For conditional `invariant` statements in module initialization."]
    ModuleInvariant = 6u32,
    #[doc = "For conditional class downcast expressions."]
    ClassDowncast = 7u32,
    #[doc = "For unhandled case arms in case statements without a default label."]
    CaseOutOfRange = 8u32,
    #[doc = "For functions that return without producing a result."]
    NoResult = 9u32,
}
impl AbortReason {
    #[doc = "Fixed (i.e. non-dynamic) size of the type, in bytes."]
    pub const fn fixed_size() -> usize { 4usize }
    #[doc = "Size of the type, in bytes."]
    pub fn size(&self) -> usize { 4usize }
    pub fn error_code(&self) -> usize {
        match self {
            Self::Assert => 21usize,
            Self::PreInvariant => 16usize,
            Self::PostInvariant => 17usize,
            Self::ForInvariant => 18usize,
            Self::LoopInvariant => 19usize,
            Self::ModuleInvariant => 20usize,
            Self::ClassDowncast => 10000usize,
            Self::CaseOutOfRange => 25usize,
            Self::NoResult => 26usize,
        }
    }
    pub fn message(&self) -> &'static str {
        match self {
            Self::Assert => "Assert condition is false",
            Self::PreInvariant => "Pre condition is false",
            Self::PostInvariant => "Post condition is false",
            Self::ForInvariant => "For-loop invariant is false",
            Self::LoopInvariant => "Loop invariant is false",
            Self::ModuleInvariant => "Module invariant is false",
            Self::ClassDowncast => "Cannot convert pointer to more specific class",
            Self::CaseOutOfRange => "Case selector is out of range",
            Self::NoResult => "Function failed to give a result",
        }
    }
}
#[doc = "Valid put items for [**PUT**].\n\n[**PUT**]: Opcode::PUT"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u32)]
pub enum PutKind {
    #[doc = "Boolean item for putting `boolean` values."]
    Boolean = 0u32,
    #[doc = "Char item for putting `char` values."]
    Char = 1u32,
    #[doc = "CharN item for putting `char(N)` values.\n\n## Note\nThe stack argument ordering is emitted in the opposite order from original Turing, where `width` and `length` are swapped.\nThis uses the ordering from the bytecode executor, which is the ultimate consumer of the bytecode anyways."]
    CharN = 2u32,
    #[doc = "Enum item for putting `enum` types.\n\nPoints to a list of variant names."]
    Enum = 3u32,
    #[doc = "Int item for putting `int` types, with only the width argument."]
    Int = 4u32,
    #[doc = "Int item for putting `int` types, with the width and fractional width arguments."]
    IntFract = 5u32,
    #[doc = "Int item for putting `int` types, with the width, fractional width, and exponent width arguments."]
    IntExp = 6u32,
    #[doc = "Nat item for putting `nat` types, with only the width argument."]
    Nat = 7u32,
    #[doc = "Nat item for putting `nat` types, with the width and fractional width arguments."]
    NatFract = 8u32,
    #[doc = "Nat item for putting `nat` types, with the width, fractional width, and exponent width arguments."]
    NatExp = 9u32,
    #[doc = "Real item for putting `real` types, with only the width argument."]
    Real = 10u32,
    #[doc = "Real item for putting `real` types, with the width and fractional width arguments."]
    RealFract = 11u32,
    #[doc = "Real item for putting `real` types, with the width, fractional width, and exponent width arguments."]
    RealExp = 12u32,
    #[doc = "String item for putting `string` types."]
    String = 13u32,
    #[doc = "Skip item, only putting a newline."]
    Skip = 14u32,
}
impl PutKind {
    #[doc = "Fixed (i.e. non-dynamic) size of the type, in bytes."]
    pub const fn fixed_size() -> usize { 4usize }
    #[doc = "Size of the type, in bytes."]
    pub fn size(&self) -> usize { 4usize }
}
#[doc = "Valid get items for [**GET**].\n\nIn Turing/OpenTuring, only Basic Latin (the non-extended ASCII range) characters are accepted in text streams, but this is only an implementation restriction.\n\n## Tokens\n\nFor some get items, characters are in groups of tokens.\nTokens may have leading whitespace (`\\x20`, `\\t`, `\\n`, `\\f`), followed by either unquoted text, or quoted text potentially containing the standard Turing backslash and caret escape characters, and potentially followed by trailing whitespace (`\\x20`, `\\t`, `\\f`).\nFor [`GetKind::Skip`], the whitespace groups are collapsed together as it does not consume any non-whitespace characters.\n\n[**GET**]: Opcode::GET\n[`GetKind::Skip`]: GetKind::Skip"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u32)]
pub enum GetKind {
    #[doc = "`boolean` item, only accepting a `true` or `false` token."]
    Boolean {
        #[doc = "Size of the value to store.\nAlways 1 for `boolean` items."]
        size: Nat4,
    } = 0u32,
    #[doc = "`char` item, accepting a literal `char` value."]
    Char {
        #[doc = "Size of the value to store.\nAlways 1 for `char` items."]
        size: Nat4,
    } = 1u32,
    #[doc = "`char` item, accepting a literal `char` value within the accepted value range.\n`min` and `max` form an inclusive range of `[min..max]`.\n\n## Note\n\nTuring/OpenTuring do not validate that the `char` value is within the specified range. "]
    CharRange {
        #[doc = "Size of the value to store.\nAlways 1 for `char` items."]
        size: Nat4,
        #[doc = "Minimum accepted `char` value."]
        min: Nat4,
        #[doc = "Maximum accepted `char` value."]
        max: Nat4,
    } = 2u32,
    #[doc = "`char(N)` item, accepting a literal `char(N)` value of the specified byte length `size`."]
    CharN {
        #[doc = "Size of the value to store.\nIgnored for `char(N)` items."]
        size: Nat4,
    } = 3u32,
    #[doc = "`enum` item, accepting a token corresponding to one of the possible variant names."]
    Enum {
        #[doc = "Size of the value to store.\nCorresponds to the size of the backing `enum` type."]
        size: Nat4,
    } = 4u32,
    #[doc = "`enum` item, accepting a token corresponding to one of the possible variant names within the accepted ordinal range.\n`min` and `max` form an inclusive range of `[min..max]`."]
    EnumRange {
        #[doc = "Size of the value to store.\nCorresponds to the size of the backing `enum` type."]
        size: Nat4,
        #[doc = "Minimum accepted `enum` ordinal value."]
        min: Nat4,
        #[doc = "Maximum accepted `enum` ordinal value."]
        max: Nat4,
    } = 5u32,
    #[doc = "`int` item, accepting an `int` token value (in base 10) within the accepted range.\n`min` and `max` form an inclusive range of `[min..max]`."]
    Int {
        #[doc = "Size of the value to store.\nMay be one of 1, 2, or 4 (corresponding to `int1`, `int2`, or `int4`)."]
        size: Nat4,
    } = 6u32,
    #[doc = "`int` item, accepting an `int` token value (in base 10)."]
    IntRange {
        #[doc = "Size of the value to store.\nMay be one of 1, 2, or 4 (corresponding to `int1`, `int2`, or `int4`)."]
        size: Nat4,
        #[doc = "Minimum accepted `int` value."]
        min: Int4,
        #[doc = "Maximum accepted `int` value."]
        max: Int4,
    } = 7u32,
    #[doc = "`nat` item, accepting a `nat` token value (in base 10)."]
    Nat {
        #[doc = "Size of the value to store.\nMay be one of 1, 2, or 4 (corresponding to `nat1`, `nat2`, or `nat4`)."]
        size: Nat4,
    } = 8u32,
    #[doc = "`real` item, accepting a `real` token value."]
    Real {
        #[doc = "Size of the value to store.\nMay be either 4 or 8 (corresponding to `real4`, or `real8`)."]
        size: Nat4,
    } = 9u32,
    #[doc = "`string` item, accepting exactly `width` literal `string` characters."]
    StringExact {
        #[doc = "Size of the value to store.\nIgnored for `string` items."]
        size: Nat4,
    } = 10u32,
    #[doc = "`string` item, accepting literal `string` characters up to the first found newline (`\n`) character."]
    StringLine {
        #[doc = "Size of the value to store.\nIgnored for `string` items."]
        size: Nat4,
    } = 11u32,
    #[doc = "`string` item, accepting a token of `string` characters."]
    StringToken {
        #[doc = "Size of the value to store.\nIgnored for `string` items."]
        size: Nat4,
    } = 12u32,
    #[doc = "Skips the stream to the first non-whitespace character."]
    Skip = 13u32,
}
impl GetKind {
    #[doc = "Size of the type, in bytes.\nIncludes the size of the tag, and may vary in size depending on the variant."]
    pub fn size(&self) -> usize {
        match self {
            Self::Boolean { .. } => 8,
            Self::Char { .. } => 8,
            Self::CharRange { .. } => 16,
            Self::CharN { .. } => 8,
            Self::Enum { .. } => 8,
            Self::EnumRange { .. } => 16,
            Self::Int { .. } => 8,
            Self::IntRange { .. } => 8,
            Self::Nat { .. } => 8,
            Self::Real { .. } => 8,
            Self::StringExact { .. } => 8,
            Self::StringLine { .. } => 8,
            Self::StringToken { .. } => 8,
            Self::Skip => 4,
        }
    }
}
#[doc = "Which stream to get the handle for in [**SETSTDSTREAM**].\n\n[**SETSTDSTREAM**]: Opcode::SETSTDSTREAM"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u32)]
pub enum StdStreamKind {
    #[doc = "Stream handle for a `get`, which uses the standard in stream."]
    Get = 1u32,
    #[doc = "Stream handle for a `put`, which uses the standard out stream."]
    Put = 2u32,
}
impl StdStreamKind {
    #[doc = "Fixed (i.e. non-dynamic) size of the type, in bytes."]
    pub const fn fixed_size() -> usize { 4usize }
    #[doc = "Size of the type, in bytes."]
    pub fn size(&self) -> usize { 4usize }
    pub fn default_handle(&self) -> isize {
        match self {
            Self::Get => -2isize,
            Self::Put => -1isize,
        }
    }
}
#[doc = "How to prepare the stream handle for the specified stream operation."]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u32)]
pub enum StreamKind {
    #[doc = "Default stream operation, which is assumed to be a `put` operation."]
    Default = 0u32,
    #[doc = "Prepare stream for a `get` operation."]
    Get = 1u32,
    #[doc = "Prepare stream for a `put` operation."]
    Put = 2u32,
    #[doc = "Prepare stream for a `read` operation."]
    Read = 3u32,
    #[doc = "Prepare stream for a `write` operation."]
    Write = 4u32,
}
impl StreamKind {
    #[doc = "Fixed (i.e. non-dynamic) size of the type, in bytes."]
    pub const fn fixed_size() -> usize { 4usize }
    #[doc = "Size of the type, in bytes."]
    pub fn size(&self) -> usize { 4usize }
}
#[doc = "Which kind of check is being performed in a [**CHKRANGE**].\n\n[**CHKRANGE**]: Opcode::CHKRANGE"]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[repr(u32)]
pub enum CheckKind {
    #[doc = "Range check as part of an assignment."]
    Assign = 0u32,
    #[doc = "Negative or zero char(*) length."]
    AnyChar = 1u32,
    #[doc = "Value passed to `chr` is not in `[0,255]`."]
    Chr = 2u32,
    #[doc = "After an arithmetic operation."]
    IntOverflow = 3u32,
    #[doc = "Range check as part of an assignemt into a range."]
    RangeAssign = 4u32,
    #[doc = "Computation of a for-loop step."]
    LoopStep = 5u32,
    #[doc = "Asserting that `pred` isn't applied on the first element of a sequence."]
    Pred = 6u32,
    #[doc = "Asserting that `succ` isn't applied on the last element of a sequence."]
    Succ = 7u32,
    #[doc = "Asserting that a value is a valid tag for a given union."]
    TagValue = 8u32,
    #[doc = "Range check as part of range parameter passing."]
    ValueParam = 9u32,
}
impl CheckKind {
    #[doc = "Fixed (i.e. non-dynamic) size of the type, in bytes."]
    pub const fn fixed_size() -> usize { 4usize }
    #[doc = "Size of the type, in bytes."]
    pub fn size(&self) -> usize { 4usize }
}
#[doc = "Keeps track of for-loop state, as well as enough state to restart iterations of a for-loop."]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ForDescriptor {
    #[doc = "Current for-loop counter variable, may be exposed via naming the counter variable."]
    pub counter: Int4,
    #[doc = "Termination value of the for-loop.\nOnce `counter` is equal to `end`, the for-loop will no longer proceed to further iterations."]
    pub end: Int4,
    #[doc = "Value to adjust `counter` by after each iteration."]
    pub step: Int4,
    #[doc = "Stack pointer address before the for-loop body was entered."]
    pub save_sp: Addrint,
}
impl ForDescriptor {
    #[doc = "Fixed (i.e. non-dynamic) size of the type, in bytes."]
    pub const fn fixed_size() -> usize { 16usize }
    #[doc = "Size of the type, in bytes."]
    pub fn size(&self) -> usize { 16usize }
}
