// Bytecode specification for the original Turing 4.x VM
//
// Some invariants to keep in mind:
// - No address to the operand stack can ever be used for instructions,
//   they must always be uplifted into addresses in the locals area.

types {
  scalar "int4" size=4 {
    description """
    32-bit signed integer.
    """
    repr_type "i32"
  }
  scalar "nat4" size=4 {
    description """
    32-bit unsigned integer.
    """
    repr_type "u32"
  }
  scalar "real4" size=4 {
    description """
    binary32 floating-point number.
    """
    repr_type "f32"
  }
  scalar "real8" size=8 {
    description """
    binary64 floating-point number.
    """
    repr_type "f64"
  }
  scalar "offset" size=4 {
    description """
    Address-sized signed integer to offset an `addrint` address with.
    Always a 32-bit integer, and is always less than or equal to 2^31 - 1 and greater than or equal to -2^31.
    Allocations can never exceed the size of an offset, and are thus limited to a maximum of 2^31 - 1 bytes.
    """
    repr_type "u32"
  }
  struct "relocatable_offset" size=8 {
    description """
    Relocatable address that is resolved at runtime.
    This is an entry within a relocatable patch list, with `link` pointing to the next entry in the list.
    Each distinct relocatable patch list refers to the local code unit sections (code, manifest, and global), as well as to other code units's sections.
    """
    link "int4" { description "Offset to the next relocatable patch entry to fixup." }
    offset "int4" { description "Offset within the section, relative to the base address." }
  }
  scalar "addrint" size=4 {
    descripton """
    Pointer-sized unsigned integer referring to a specific location in the execution address space.
    This is always a 32-bit integer as 64-bit execution address spaces are unsupported.
    """
    repr_type "u32"
  }
  enum "abort_reason" size=4 {
    description """
    The reason for aborting program execution
    """
    repr_type "u32"

    assert 1 {
      description "For conditional `assert` statements"
      message "Assert condition is false"
      error_code 21
    }
    pre_invariant 2 {
      description "For conditional `pre` statements"
      message "Pre condition is false"
      error_code 16
    }
    post_invariant 3 {
      description "For conditional `post` statements"
      message "Post condition is false"
      error_code 17
    }
    for_invariant 4 {
      description "For conditional `invariant` statements in for-loops"
      message "For-loop invariant is false"
      error_code 18
    }
    loop_invariant 5 {
      description "For conditional `invariant` statements in loops"
      message "Loop invariant is false"
      error_code 19
    }
    module_invariant 6 {
      description "For conditional `invariant` statements in module initialization"
      message "Module invariant is false"
      error_code 20
    }
    class_downcast 7 {
      description "For conditional class downcast expressions"
      message "Cannot convert pointer to more specific class"
      error_code 10_000
    }
    case_out_of_range 8 {
      description "For unhandled case arms in case statements without a default label"
      message "Case selector is out of range"
      error_code 25
    }
    no_result 9 {
      descrption "For functions that return without producing a result"
      message "Function failed to give a result"
      error_code 26
    }
  }
}

instructions {
  group "Abort Program" {
    description """
    Aborts program execution for a specific reason.

    The specific abort reason depends on the `abort_kind`, which is always provided
    as an operand. The instruction is invalid if `abort_kind` is not one of the
    expected abort types.
    """

    ABORT 0x00 "Abort" {
      description """
      Always aborts program execution.
      """
      operands {
        abort_kind "abort_reason" {
          description """
          What is the reason for aborting
          """
        }
      }
    }

    ABORTCOND 0x01 "Abort If Condition is False" {
      description """
      Conditionally aborts program execution based on `will_abort`.
      """
      operands {
        abort_kind "abort_reason" {
          description """
          What is the reason for aborting
          """
        }
      }
      stack_before {
        condition_holds "int4" {
          description """
          If the condition to assert holds, otherwise aborts program execution (i.e. `condition_holds` is 0).
          """
        }
      }
      stack_after {
        empty
      }
    }
  }

  group "Add Numbers" {
    description "Performs addition on two numbers."

    ADDINT 0x04 "Add Integers" {
      description "Adds `lhs` and `rhs`, producing `out`."
      operands {}
      stack_before {
        lhs "int4" { description "Left-hand side of operation" }
        rhs "int4" { description "Right-hand side of operation" }
      }
      stack_after {
        out "int4" { description "Result of operation" }
      }
    }
    
    ADDINTNAT 0x05 "Add Integer with Natural" {
      description "Adds `lhs` and `rhs`, producing `out`."
      operands {}
      stack_before {
        lhs "int4" { description "Left-hand side of operation" }
        rhs "nat4" { description "Right-hand side of operation" }
      }
      stack_after {
        out "int4" { description "Result of operation" }
      }
    }
    
    ADDNAT 0x06 "Add Naturals" {
      description "Adds `lhs` and `rhs`, producing `out`."
      operands {}
      stack_before {
        lhs "nat4" { description "Left-hand side of operation" }
        rhs "nat4" { description "Right-hand side of operation" }
      }
      stack_after {
        out "nat4" { description "Result of operation" }
      }
    }
    
    ADDNATINT 0x07 "Add Natural with Integer" {
      description "Adds `lhs` and `rhs`, producing `out`."
      operands {}
      stack_before {
        lhs "nat4" { description "Left-hand side of operation" }
        rhs "int4" { description "Right-hand side of operation" }
      }
      stack_after {
        out "nat4" { description "Result of operation" }
      }
    }
    
    ADDNATINT 0x08 "Add Reals" {
      description "Adds `lhs` and `rhs`, producing `out`."
      operands {}
      stack_before {
        lhs "real8" { description "Left-hand side of operation" }
        rhs "real8" { description "Right-hand side of operation" }
      }
      stack_after {
        out "real8" { description "Result of operation" }
      }
    }
  }

  CALL 0x32 "Call Procedure" {
    description """
    Changes execution to follow the procedure at the provided call address.
    Standard call ABI (that is, the call ABI of Turing/OpenTuring) requires that the call address be pushed before all of the operands.
    """

    operands {
      address_offset "offset" { description "Offset to the call address in the stack" }
    }
    stack_before {}
    stack_after {
      return_addr "addrint" { description "Return address" }
    }
  }

  CASE 0x35 "Case Of" {
    description """
    Jumps to a specific branch depending on `selector`.
    `descriptor` points to a case descriptor describing the case bounds, default branch offset, and per-entry branch.
    Succinctly, it is of the following layout:

    | Type     | Name           |
    |----------|----------------|
    | `int4`   | lower_bound    |
    | `int4`   | upper_bound    | 
    | `offset` | default_branch |
    | `offset` | arm_0          |
    | `offset` | arm_1          |
    | ...      | ...            |
    | `offset` | arm_n          |

    Note that the case descriptor cannot have more than 1000 arm offsets when targeting Turing/OpenTuring interpreters.

    All offsets are relative to the address of the `descriptor` operand.
    """

    operands {
      descriptor "offset" {
        description """
        Offset to the case descriptor table describing the jump targets
        """
      }
    }
    stack_before {
      selector "int4" { description "Selects which case target entry to use" }
    }
    stack_after {}
  }

  group "Locate Address" {
    LOCATELOCAL 0x96 "Locate Local Slot" {
      description """
      Locates the address of a local in the current call frame.
      Offset is computed relative to the start of the local area.
      """

      operands {
        offset "offset" { description "Offset in the locals area" }
      }
      stack_before {}
      stack_after {
        address "addrint" { description "Address of the computed local slot" }
      }
    }

    LOCATETEMP 0x98 "Locate Temporary Slot" {
      description """
      Locates the address of a temporary in the current call frame.
      Offset is computed relative to the start of the temporaries area.

      As the temporaries area is located after the locals area in the call frame, the size of the call frame must also be known.
      """

      operands {
        frame_size "nat4" { description "Size of the call frame." }
        offset "offset" { description "Offset in the temporary area" }
      }
      stack_before {}
      stack_after {
        address "addrint" { description "Address of the computed temporary slot" }
      }
    }
  }

  group "Jump" {
    description """
    Changes program execution forwards or backwards. 
    """
    
    JUMP 0x89 "Jump Forward" {
      description """
      Advances program counter forwards by `offset` bytes.
      Offset is relative to the address of the offset operand.
      """

      operands {
        offset "offset" { description "Offset to jump forward by, in bytes" }
      }
    }

    JUMPB 0x8A "Jump Backward" {
      description """
      Retreats program counter backwards by `offset` bytes.
      Offset is relative to the address of the offset operand.
      """
      
      operands {
        offset "offset" { description "Offset to jump backwards by, in bytes" }
      }
    }
  }

  PROC 0xBA "Begin Procedure" {
    operands {
      frame_size "nat4" {
        description "Size of the call frame to allocate for locals and temporaries."
      }
    }
    // TODO: Stack effect (needs computed for frame size)
  }

  group "Push Value Onto Stack" {
    PUSHADDR1 0xBC "Push Relocatable Address" {
      description """
      Pushes a relocatable address with a runtime-determined base address.

      This may be relative to the base address of the local or external code unit section (code, manifest, or global).
      """
      operands {
        offset "relocatable_offset" { description "Runtime-resolved offset within a section." }
      }
      stack_before {}
      stack_after {
        addr "addrint" { description "Computed offset and base address." }
      }
    }

    PUSHVAL0 0xC2 "Push Literal 0" {
      description """
      Pushes a literal 0 value onto the operand stack.
      """
      operands {}
      stack_before {}
      stack_after {
        zero "int4" { description "Literal 0 value" }
      }
    }

    PUSHVAL1 0xC3 "Push Literal 1" {
      description """
      Pushes a literal 1 value onto the operand stack.
      """
      operands {}
      stack_before {}
      stack_after {
        one "int4" { description "Literal 1 value" }
      }
    }
  }
}
