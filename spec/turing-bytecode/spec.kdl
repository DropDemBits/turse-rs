// Bytecode specification for the original Turing 4.x VM
//
// Some invariants to keep in mind:
// - No address to the operand stack can ever be used for instructions,
//   they must always be uplifted into addresses in the locals area.

types {
  scalar "int1" size=1 {
    description """
    8-bit signed integer.
    """
    repr_type "i8"
  }
  scalar "int2" size=2 {
    description """
    16-bit signed integer.
    """
    repr_type "i16"
  }
  scalar "int4" size=4 {
    description """
    32-bit signed integer.

    `0x80000000` is used as a sentinel value in `int` to represent uninitialized `int` variables.
    `int4` values have no such sentinel values.
    """
    repr_type "i32"
  }
  scalar "nat2" size=2 {
    description """
    16-bit unsigned integer.
    """
    repr_type "u16"
  }
  scalar "nat4" size=4 {
    description """
    32-bit unsigned integer.

    `0xFFFFFFFF` is used as a sentinel value in `nat` to represent uninitialized `nat` variables.
    `nat4` values have no such sentinel values.
    """
    repr_type "u32"
  }
  scalar "real4" size=4 {
    description """
    binary32 floating-point number.
    """
    repr_type "f32"
  }
  scalar "real8" size=8 {
    description """
    binary64 floating-point number.
    """
    repr_type "f64"
  }
  scalar "set16" size=2 {
    description """
    Element of a large bitset, storing up to 16 elements.
    Sets larger than 4 bytes (32 elements) store the backing bitset as a separate allocation of an array of `set16`s.
    """
    repr_type "u16"
  }
  scalar "set32" size=4 {
    description """
    Compact bitset, storing up to 32 elements.
    Sets up to 4 bytes in size store the backing bitset inline with the value.
    """
    repr_type "u32"
  }
  scalar "offset" size=4 {
    description """
    Address-sized signed integer to offset an `addrint` address with.
    Always a 32-bit integer, and is always less than or equal to 2^31 - 1 and greater than or equal to -2^31.
    Allocations can never exceed the size of an offset, and are thus limited to a maximum of 2^31 - 1 bytes.

    `0xFFFFFFFF` is used as a sentinel value to represent uninitialized `addrint` variables.
    """
    repr_type "u32"
  }
  struct "relocatable_offset" size=8 {
    description """
    Relocatable address that is resolved at runtime.
    This is an entry within a relocatable patch list, with `link` pointing to the next entry in the list.
    Each distinct relocatable patch list refers to the local code unit sections (code, manifest, and global), as well as to other code units's sections.
    """

    link "offset" { description "Offset to the next relocatable patch entry to fixup." }
    offset "offset" { description "Offset within the section, relative to the base address." }
  }
  scalar "addrint" size=4 {
    description """
    Pointer-sized unsigned integer referring to a specific location in the execution address space.
    This is always a 32-bit integer as 64-bit execution address spaces are unsupported.
    """
    repr_type "u32"
  }
  enum "abort_reason" size=4 {
    description """
    The reason for aborting program execution
    """
    repr_type "u32"

    assert 1 {
      description "For conditional `assert` statements."
      message "Assert condition is false"
      error_code 21
    }
    pre_invariant 2 {
      description "For conditional `pre` statements."
      message "Pre condition is false"
      error_code 16
    }
    post_invariant 3 {
      description "For conditional `post` statements."
      message "Post condition is false"
      error_code 17
    }
    for_invariant 4 {
      description "For conditional `invariant` statements in for-loops."
      message "For-loop invariant is false"
      error_code 18
    }
    loop_invariant 5 {
      description "For conditional `invariant` statements in loops."
      message "Loop invariant is false"
      error_code 19
    }
    module_invariant 6 {
      description "For conditional `invariant` statements in module initialization."
      message "Module invariant is false"
      error_code 20
    }
    class_downcast 7 {
      description "For conditional class downcast expressions."
      message "Cannot convert pointer to more specific class"
      error_code 10_000
    }
    case_out_of_range 8 {
      description "For unhandled case arms in case statements without a default label."
      message "Case selector is out of range"
      error_code 25
    }
    no_result 9 {
      description "For functions that return without producing a result."
      message "Function failed to give a result"
      error_code 26
    }
  }
  enum "put_kind" size=4 {
    description """
    Valid put items for **PUT**.
    """
    repr_type "u32"

    boolean 0 {
      description """
      Boolean item for putting `boolean` values.
      """
    }
    char 1 {
      description """
      Char item for putting `char` values.
      """
    }
    char_n 2 {
      description """
      CharN item for putting `char(N)` values.

      ## Note
      The stack argument ordering is emitted in the opposite order from original Turing, where `width` and `length` are swapped.
      This uses the ordering from the bytecode executor, which is the ultimate consumer of the bytecode anyways.
      """
    }
    enum 3 {
      description """
      Enum item for putting `enum` types.

      Points to a list of variant names.
      """
    }
    int 4 {
      description """
      Int item for putting `int` types, with only the width argument.
      """
    }
    int_fract 5 {
      description """
      Int item for putting `int` types, with the width and fractional width arguments.
      """
    }
    int_exp 6 {
      description """
      Int item for putting `int` types, with the width, fractional width, and exponent width arguments.
      """
    }
    // note: some of these nat ones crash the intepreter?
    nat 7 {
      description """
      Nat item for putting `nat` types, with only the width argument.
      """
    }
    nat_fract 8 {
      description """
      Nat item for putting `nat` types, with the width and fractional width arguments.
      """
    }
    nat_exp 9 {
      description """
      Nat item for putting `nat` types, with the width, fractional width, and exponent width arguments.
      """
    }
    real 10 {
      description """
      Real item for putting `real` types, with only the width argument.
      """
    }
    real_fract 11 {
      description """
      Real item for putting `real` types, with the width and fractional width arguments.
      """
    }
    real_exp 12 {
      description """
      Real item for putting `real` types, with the width, fractional width, and exponent width arguments.
      """
    }
    string 13 {
      description """
      String item for putting `string` types.
      """
    }
    skip 14 {
      description """
      Skip item, only putting a newline.
      """
    }
  }
  enum "get_kind" size=4 {
    description """
    Valid get items for **GET**.
    """
    repr_type "u32"

    skip 14
  }
  enum "std_stream" size=4 {
    description """
    Standard streams selectable from [**SETSTDSTREAM**].

    [**SETSTDSTREAM**](Opcode::SETSTDSTREAM)
    """
    repr_type "u32"

    stdin 1 {
      description """
      Standard in stream.
      """
      default_handle -2
    }
    stdout 2 {
      description """
      Standard out stream.
      """
      default_handle -1
    }
  }
  enum "stream_kind" size=4 {
    description """
    Stream operations that can be used from [**SETSTREAM**].

    [**SETSTREAM**](Opcode::SETSTREAM)
    """
    repr_type "u32"

    seek 0 {}
    get 1 {}
    put 2 {}
    read 3 {}
    write 4 {}
  }
  enum "check_kind" size=4 {
    description "Which kind of check is being performed in a **CHKRANGE**."
    repr_type "u32"

    assign 0 {
      description "Range check as part of an assignment."
    }
    any_char 1 {
      description "Negative or zero char(*) length."
    }
    chr 2 {
      description "Value passed to `chr` is not in `[0,255]`."
    }
    int_overflow 3 {
      description "After an arithmetic operation."
    }
    range_assign 4 {
      description "Range check as part of an assignemt into a range."
    }
    loop_step 5 {
      description "Computation of a for-loop step."
    }
    pred 6 {
      description "Asserting that `pred` isn't applied on the first element of a sequence."
    }
    succ 7 {
      description  "Asserting that `succ` isn't applied on the last element of a sequence."
    }
    tag_value 8 {
      description "Asserting that a value is a valid tag for a given union." 
    }
    value_param 9 {
      description "Range check as part of range parameter passing."
    }
  }
}

instructions {
  group "Abort Program" {
    description """
    Aborts program execution for a specific reason.

    The specific abort reason depends on the `abort_kind`, which is always provided
    as an operand. The instruction is invalid if `abort_kind` is not one of the
    expected abort types.
    """

    ABORT 0x00 "Abort" {
      description """
      Always aborts program execution.
      """
      operands {
        abort_kind "abort_reason" {
          description """
          What is the reason for aborting
          """
        }
      }
    }

    ABORTCOND 0x01 "Abort If Condition is False" {
      description """
      Conditionally aborts program execution based on `will_abort`.
      """
      operands {
        abort_kind "abort_reason" {
          description """
          What is the reason for aborting
          """
        }
      }
      stack_before {
        condition_holds "int4" {
          description """
          If the condition to assert holds, otherwise aborts program execution (i.e. `condition_holds` is 0).
          """
        }
      }
      stack_after {
        empty
      }
    }
  }

  group "Add Numbers" {
    description "Performs addition on two numbers."

    ADDINT 0x04 "Add Integers" {
      description "Adds as `int` values `lhs` and `rhs`, producing `out`."
      operands {}
      stack_before {
        lhs "int4" { description "Left-hand side of operation." }
        rhs "int4" { description "Right-hand side of operation." }
      }
      stack_after {
        out "int4" { description "Result of operation." }
      }
    }
    
    ADDINTNAT 0x05 "Add Integer with Natural" {
      description "Adds `lhs` (as an `int` value) and `rhs` (as a `nat` value), producing `out`."
      operands {}
      stack_before {
        lhs "int4" { description "Left-hand side of operation." }
        rhs "nat4" { description "Right-hand side of operation." }
      }
      stack_after {
        out "int4" { description "Result of operation." }
      }
    }
    
    ADDNAT 0x06 "Add Naturals" {
      description "Adds as `nat` values `lhs` and `rhs`, producing `out`."
      operands {}
      stack_before {
        lhs "nat4" { description "Left-hand side of operation." }
        rhs "nat4" { description "Right-hand side of operation." }
      }
      stack_after {
        out "nat4" { description "Result of operation." }
      }
    }
    
    ADDNATINT 0x07 "Add Natural with Integer" {
      description "Adds `lhs` (as a `nat` value) and `rhs` (as an `int` value), producing `out`."
      operands {}
      stack_before {
        lhs "nat4" { description "Left-hand side of operation." }
        rhs "int4" { description "Right-hand side of operation." }
      }
      stack_after {
        out "nat4" { description "Result of operation." }
      }
    }
    
    ADDREAL 0x08 "Add Reals" {
      description "Adds as `real` values `lhs` and `rhs`, producing `out`."
      operands {}
      stack_before {
        lhs "real8" { description "Left-hand side of operation." }
        rhs "real8" { description "Right-hand side of operation." }
      }
      stack_after {
        out "real8" { description "Result of operation." }
      }
    }
  }

  CALL 0x32 "Call Procedure" {
    description """
    Changes execution to follow the procedure at the provided call address.
    Standard call ABI (that is, the call ABI of Turing/OpenTuring) requires that the call address be pushed before all of the operands.
    """

    operands {
      address_offset "offset" { description "Offset to the call address in the stack." }
    }
    stack_before {}
    stack_after {
      return_addr "addrint" { description "Return address." }
    }
  }

  CASE 0x35 "Case Of" {
    description """
    Jumps to a specific branch depending on `selector`.
    `descriptor` points to a case descriptor describing the case bounds, default branch offset, and per-entry branch.
    Succinctly, it is of the following layout:

    | Type     | Name           |
    |----------|----------------|
    | `int4`   | lower_bound    |
    | `int4`   | upper_bound    | 
    | `offset` | default_branch |
    | `offset` | arm_0          |
    | `offset` | arm_1          |
    | ...      | ...            |
    | `offset` | arm_n          |

    Note that the case descriptor cannot have more than 1000 arm offsets when targeting Turing/OpenTuring interpreters.

    All offsets are relative to the address of the `descriptor` operand.
    """

    operands {
      descriptor "offset" {
        description """
        Offset to the case descriptor table describing the jump targets
        """
      }
    }
    stack_before {
      selector "int4" { description "Selects which case target entry to use." }
    }
    stack_after {}
  }

  group "Compare Equal" {
    description """
    Tests if `lhs` is equal to `rhs`, putting the compare result in `compare`.
    """

    EQADDR 0x4E "Compare Equal Addresses" {
      description """
      Tests as `addrint` values if `lhs` and `rhs` are equal `addrint` values.
      """
      operands {}
      stack_before {
        lhs "addrint" { description "Left-hand side of comparison." }
        rhs "addrint" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if values are equal, 0 otherwise." }
      }
    }

    EQCHARN 0x4F "Compare Equal Char(N)" {
      description """
      Tests as `char(N)` values if `lhs` and `rhs` are equal.
      Performs a byte-by-byte comparison.
      """
      operands {
        length "nat4" {
          description """
          Byte length of the `char(N)` type.
          """
        }
      }
      stack_before {
        lhs "addrint" { description "Left-hand side of comparison." }
        rhs "addrint" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if values are equal, 0 otherwise." }
      }
    }

    EQINT 0x50 "Compare Equal Integers" {
      description """
      Tests as `int` values if `lhs` and `rhs` are equal.
      """
      operands {}
      stack_before {
        lhs "int4" { description "Left-hand side of comparison." }
        rhs "int4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if values are equal, 0 otherwise." }
      }
    }

    EQINTNAT 0x51 "Compare Equal Integer with Natural" {
      description """
      Tests if `lhs` (as an `int` value) and `rhs` (as a `nat` value) are equal values.
      If `rhs` is greater than `maxint` (`0x7FFFFFFF`), the comparison is always false.
      """
      operands {}
      stack_before {
        lhs "int4" { description "Left-hand side of comparison." }
        rhs "nat4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if values are equal, 0 otherwise." }
      }
    }

    EQNAT 0x52 "Compare Equal Nats" {
      description """
      Tests as `nat` values if `lhs` and `rhs` are equal.
      """
      operands {}
      stack_before {
        lhs "nat4" { description "Left-hand side of comparison." }
        rhs "nat4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if values are equal, 0 otherwise." }
      }
    }

    EQREAL 0x53 "Compare Equal Reals" {
      description """
      Tests as `real` values if `lhs` and `rhs` are equal.
      """
      operands {}
      stack_before {
        lhs "real8" { description "Left-hand side of comparison." }
        rhs "real8" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if values are equal, 0 otherwise." }
      }
    }

    EQSET 0x54 "Compare Equal Sets" {
      description """
      Tests as `set` values if `lhs` and `rhs` are equal.
      Performs a byte-by-byte comparison.

      `set_length` determines the size of both sets, as well as determining the set representation.
      Sets up to 4 bytes in size are stored in the compact format (as a `set32`), while sets larger than 4 bytes are stored as an indirect array of `set16`s.
      """
      operands {
        set_length "nat4" {
          description """
          Length of the set, in bytes.
          """
        }
      }
      stack_before {
        @conditional {
          @predicate (operands).set_length "<=" 4

          lhs "set32" { description "Left-hand side of comparison." }
          rhs "set32" { description "Right-hand side of comparison." }
        }
        @conditional {
          @predicate "otherwise"

          lhs "addrint" { description "Left-hand side of comparison." }
          rhs "addrint" { description "Right-hand side of comparison." }
        }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if values are equal, 0 otherwise." }
      }
    }

    EQSTR 0x55 "Compare Equal Strings" {
      description """
      Tests as `string` values if `lhs` and `rhs` are equal.
      Performs a byte-by-byte comparison.
      """
      operands {}
      stack_before {
        lhs "addrint" { description "Left-hand side of comparison." }
        rhs "addrint" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if values are equal, 0 otherwise." }
      }
    }
  }

  group "Compare Greater Than or Equal" {
    description """
    Tests if `lhs` is greater than or equal to `rhs`, putting the compare result in `compare`.
    """

    GECHARN 0x6F "Compare Greater or Equal Char(N)" {
      description """
      Tests as `char(N)` values if `lhs` is greater than or equal to `rhs`.
      Performs a byte-by-byte comparison.
      """
      operands {
        length "nat4" {
          description """
          Byte length of the `char(N)` type.
          """
        }
      }
      stack_before {
        lhs "addrint" { description "Left-hand side of comparison." }
        rhs "addrint" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is greater than or equal to `rhs`, 0 otherwise." }
      }
    }

    GECLASS 0x70 "Compare Descendant or Same Class" {
      descriptor """
      Tests if `lhs` is a class that is a descendant of, or the same class as `rhs`.
      This navigates up the class hierarchy of `lhs` to see if `rhs` is a member of the ancestor hierarchy.

      If `lhs` is `nil` (`0x0`), the comparison is always true as `nil` is considered a descendant of all classes.
      """

      stack_before {
        lhs "addrint" { description "Left-hand side of comparison." }
        rhs "addrint" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is a descendant of, or same class as `rhs`, 0 otherwise." }
      }
    }

    GEINT 0x71 "Compare Greater or Equal Integers" {
      description """
      Tests as `int` values if `lhs` is greater than or equal to `rhs`.
      """
      operands {}
      stack_before {
        lhs "int4" { description "Left-hand side of comparison." }
        rhs "int4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is greater than or equal to `rhs`, 0 otherwise." }
      }
    }

    GEINTNAT 0x72 "Compare Greater or Equal Natural with Integer" {
      description """
      Tests if `lhs` (as an`nat` value) is greater than or equal to `rhs` (as a `nat` value).
      If `rhs` is greater than `maxint` (`0x7FFFFFFF`), the comparison is always false.
      """
      operands {}
      stack_before {
        lhs "int4" { description "Left-hand side of comparison." }
        rhs "nat4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is greater than or equal to `rhs`, 0 otherwise." }
      }
    }

    GENAT 0x73 "Compare Greater or Equal Naturals" {
      description """
      Tests as `nat` values if `lhs` is greater than or equal to `rhs`.
      """
      operands {}
      stack_before {
        lhs "nat4" { description "Left-hand side of comparison." }
        rhs "nat4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { "Result of operation. 1 if `lhs` is greater than or equal to `rhs`, 0 otherwise." }
      }
    }

    GENATINT 0x74 "Compare Greater or Equal Integer with Natural" {
      description """
      Tests if `lhs` (as a `nat` value) is greater than or equal to `rhs` (as an `int` value).
      If `lhs` is greater than `maxint` (`0x7FFFFFFF`), the comparison is always true.
      """
      operands {}
      stack_before {
        lhs "nat4" { description "Left-hand side of comparison." }
        rhs "int" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is greater than or equal to `rhs`, 0 otherwise." }
      }
    }

    GEREAL 0x75 "Compare Greater or Equal Reals" {
      description """
      Tests as `real` values if `lhs` is greater than or equal to `rhs`.
      """
      operands {}
      stack_before {
        lhs "real8" { description "Left-hand side of comparison." }
        rhs "real8" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is greater than or equal to `rhs`, 0 otherwise." }
      }
    }

    GESET 0x76 "Compare Greater or Equal Sets" {
      description """
      Tests as `set` values if `lhs` is a supeset of `rhs` (that is, all elements in `rhs` are contained in `lhs`).
      Performs a byte-by-byte comparison.

      `set_length` determines the size of both sets, as well as determining the set representation.
      Sets up to 4 bytes in size are stored in the compact format (as a `set32`), while sets larger than 4 bytes are stored as an indirect array of `set16`s.
      """
      operands {
        set_length "nat4" {
          description """
          Length of the set, in bytes.
          """
        }
      }
      stack_before {
        @conditional {
          @predicate (operands).set_length "<=" 4

          lhs "set32" { description "Left-hand side of comparison." }
          rhs "set32" { description "Right-hand side of comparison." }
        }
        @conditional {
          @predicate "otherwise"

          lhs "addrint" { description "Left-hand side of comparison." }
          rhs "addrint" { description "Right-hand side of comparison." }
        }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is greater than or equal to `rhs`, 0 otherwise." }
      }
    }

    GESTR 0x77 "Compare Greater or Equal Strings" {
      description """
      Tests as `string` values if `lhs` is greater than or equal to `rhs`.
      Performs a byte-by-byte comparison.
      """
      operands {}
      stack_before {
        lhs "addrint" { description "Left-hand side of comparison." }
        rhs "addrint" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is greater than or equal to `rhs`, 0 otherwise." }
      }
    }
  }

  GTCLASS 0x7A "Compare Descendant Class" {
    descriptor """
    Tests if `lhs` is a class that is a descendant of `rhs`.
    This navigates up the class hierarchy of `lhs` to see if `rhs` is a member of the ancestor hierarchy.

    If `lhs` is `nil` (`0x0`), the comparison is always true as `nil` is considered a descendant of all classes.
    """

    stack_before {
      lhs "addrint" { description "Left-hand side of comparison." }
      rhs "addrint" { description "Right-hand side of comparison." }
    }
    stack_after {
      compare "int4" { description "Result of operation. 1 if `lhs` is a descendant of `rhs`, 0 otherwise." }
    }
  }

  group "Compare Less or Equal" {
    description """
    Tests if `lhs` is less than or equal to `rhs`, putting the compare result in `compare`.
    """

    LECHARN 0x8B "Compare Less or Equal Char(N)" {
      description """
      Tests as `char(N)` values if `lhs` is less than or equal to `rhs`.
      Performs a byte-by-byte comparison.
      """
      operands {
        length "nat4" {
          description """
          Byte length of the `char(N)` type.
          """
        }
      }
      stack_before {
        lhs "addrint" { description "Left-hand side of comparison." }
        rhs "addrint" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is less than or equal to `rhs`, 0 otherwise." }
      }
    }

    LECLASS 0x8C "Compare Ancestor or Same Class" {
      descriptor """
      Tests if `lhs` is a class that is an ancestor of, or the same class as `rhs`.
      This navigates up the class hierarchy of `lhs` to see if `rhs` is a member of the ancestor hierarchy.

      If `rhs` is `nil` (`0x0`), the comparison is always true as `nil` is considered a descendant of all classes.
      """

      stack_before {
        lhs "addrint" { description "Left-hand side of comparison." }
        rhs "addrint" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is a descendant of, or same class as `rhs`, 0 otherwise." }
      }
    }

    LEINT 0x8D "Compare Less or Equal Integers" {
      description """
      Tests as `int` values if `lhs` is less than or equal to `rhs`.
      """
      operands {}
      stack_before {
        lhs "int4" { description "Left-hand side of comparison." }
        rhs "int4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is less than or equal to `rhs`, 0 otherwise." }
      }
    }

    LEINTNAT 0x8E "Compare Less or Equal Natural with Integer" {
      description """
      Tests if `lhs` (as an `int` value) is less than or equal to `rhs` (as a `nat` value).
      If `rhs` is greater than `maxint` (`0x7FFFFFFF`), the comparison is always true.
      """
      operands {}
      stack_before {
        lhs "int4" { description "Left-hand side of comparison." }
        rhs "nat4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is less than or equal to `rhs`, 0 otherwise." }
      }
    }

    LENAT 0x8F "Compare Less or Equal Naturals" {
      description """
      Tests as `nat` values if `lhs` is less than or equal to `rhs`.
      """
      operands {}
      stack_before {
        lhs "nat4" { description "Left-hand side of comparison." }
        rhs "nat4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is less than or equal to `rhs`, 0 otherwise." }
      }
    }

    LENATINT 0x90 "Compare Less or Equal Integer with Natural" {
      description """
      Tests if `lhs` (as a `nat` value) is less than or equal to `rhs` (as an `int` value).
      If `lhs` is greater than `maxint` (`0x7FFFFFFF`), the comparison is always false.
      """
      operands {}
      stack_before {
        lhs "nat4" { description "Left-hand side of comparison." }
        rhs "int4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is less than or equal to `rhs`, 0 otherwise." }
      }
    }

    LEREAL 0x91 "Compare Less or Equal Reals" {
      description """
      Tests as `real` values if `lhs` is less than or equal to `rhs`.
      """
      operands {}
      stack_before {
        lhs "real8" { description "Left-hand side of comparison." }
        rhs "real8" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is less than or equal to `rhs`, 0 otherwise." }
      }
    }

    LESET 0x92 "Compare Less or Equal Sets" {
      description """
      Tests as `set` values if `lhs` is a subset of `rhs` (that is, all elements in `lhs` are contained in `rhs`).
      Performs a byte-by-byte comparison.

      `set_length` determines the size of both sets, as well as determining the set representation.
      Sets up to 4 bytes in size are stored in the compact format (as a `set32`), while sets larger than 4 bytes are stored as an indirect array of `set16`s.
      """
      operands {
        set_length "nat4" {
          description """
          Length of the set, in bytes.
          """
        }
      }
      stack_before {
        @conditional {
          @predicate (operands).set_length "<=" 4

          lhs "set32" { description "Left-hand side of comparison." }
          rhs "set32" { description "Right-hand side of comparison." }
        }
        @conditional {
          @predicate "otherwise"

          lhs "addrint" { description "Left-hand side of comparison." }
          rhs "addrint" { description "Right-hand side of comparison." }
        }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is less than or equal to `rhs`, 0 otherwise." }
      }
    }

    LESTR 0x93 "Compare Less or Equal Strings" {
      description """
      Tests as `string` values if `lhs` is less than or equal to `rhs`.
      Performs a byte-by-byte comparison.
      """
      operands {}
      stack_before {
        lhs "addrint" { description "Left-hand side of comparison." }
        rhs "addrint" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is less than or equal to `rhs`, 0 otherwise." }
      }
    }
  }

  group "Jump" {
    description """
    Changes program execution forwards or backwards. 
    """
    
    JUMP 0x89 "Jump Forward" {
      description """
      Advances program counter forwards by `offset` bytes.
      Offset is relative to the address of the offset operand.
      """

      operands {
        offset "offset" { description "Offset to jump forward by, in bytes." }
      }
    }

    JUMPB 0x8A "Jump Backward" {
      description """
      Retreats program counter backwards by `offset` bytes.
      Offset is relative to the address of the offset operand.
      """
      
      operands {
        offset "offset" { description "Offset to jump backwards by, in bytes." }
      }
    }
  }

  group "Locate Address" {
    LOCATELOCAL 0x96 "Locate Local Slot" {
      description """
      Locates the address of a local in the current call frame.
      Offset is computed relative to the start of the local area.
      """

      operands {
        offset "offset" { description "Offset in the locals area." }
      }
      stack_before {}
      stack_after {
        address "addrint" { description "Address of the computed local slot." }
      }
    }

    LOCATETEMP 0x98 "Locate Temporary Slot" {
      description """
      Locates the address of a temporary in the current call frame.
      Offset is computed relative to the start of the temporaries area.

      As the temporaries area is located after the locals area in the call frame, the size of the call frame must also be known.
      """

      operands {
        frame_size "nat4" { description "Size of the call frame." }
        offset "offset" { description "Offset in the temporary area." }
      }
      stack_before {}
      stack_after {
        address "addrint" { description "Address of the computed temporary slot." }
      }
    }
  }

  LTCLASS 0x99 "Compare Ancestor Class" {
    descriptor """
    Tests if `lhs` is a class that is an ancestor of `rhs`.
    This navigates up the class hierarchy of `lhs` to see if `rhs` is a member of the ancestor hierarchy.

    If `rhs` is `nil` (`0x0`), the comparison is always true as `nil` is considered a descendant of all classes.
    """

    stack_before {
      lhs "addrint" { description "Left-hand side of comparison." }
      rhs "addrint" { description "Right-hand side of comparison." }
    }
    stack_after {
      compare "int4" { description "Result of operation. 1 if `lhs` is a descendant of `rhs`, 0 otherwise." }
    }
  }

  PROC 0xBA "Begin Procedure" {
    // TODO: Description
    operands {
      frame_size "nat4" {
        description "Size of the call frame to allocate for locals and temporaries."
      }
    }
    // TODO: Stack effect (needs computed for frame size)
  }

  group "Push Value Onto Stack" {
    PUSHADDR 0xBB "Push Address" {
      description """
      Pushes an absolute address. The address will not be relocated.
      """

      operands {
        addr "addrint" { description "Absolute address to refer to."}
      }
      stack_before {}
      stack_after {
        addr "addrint" { description "Absolute address." }
      }
    }

    PUSHADDR1 0xBC "Push Relocatable Address" {
      description """
      Pushes a relocatable address with a runtime-determined base address.

      This may be relative to the base address of the local or external code unit section (code, manifest, or global).
      """
      operands {
        offset "relocatable_offset" { description "Runtime-resolved offset within a section." }
      }
      stack_before {}
      stack_after {
        addr "addrint" { description "Computed offset and base address." }
      }
    }

    PUSHCOPY 0xBD "Push Copy of Value" {
      description """
      Pushes a copy of the top value on the operand stack.

      Will only copy `nat4` sized or smaller values.
      """

      operands {}
      stack_before {
        value "nat4" { description "Value to copy." }
      }
      stack_after {
        value "nat4" {
          description "Original value to copy."
          preserves (stack_before).value
        }
        copy "nat4" {
          description "Copied value."
        }
      }
    }

    PUSHINT 0xBE "Push Literal Integer Value" {
      description """
      Pushes a literal `int` value onto the operand stack.
      """

      operands {
        literal "int4" { description "Literal value to push." }
      }
      stack_before {}
      stack_after {
        value "int4" {
          description "Literal value pushed onto the operand stack."
        }
      }
    }

    PUSHINT1 0xBF "Push Literal Int1 Value" {
      description """
      Pushes a literal `int1` value onto the operand stack.
      """

      operands {
        literal "int1" { description "Literal value to push." }
      }
      stack_before {}
      stack_after {
        value "int1" {
          description "Literal value pushed onto the operand stack."
        }
      }
    }

    PUSHINT2 0xC0 "Push Literal Int2 Value" {
      description """
      Pushes a literal `int2` value onto the operand stack.
      """

      operands {
        literal "int2" { description "Literal value to push." }
      }
      stack_before {}
      stack_after {
        value "int2" {
          description "Literal value pushed onto the operand stack."
        }
      }
    }

    PUSHREAL 0xC1 "Push Literal Real Value" {
      description """
      Pushes a literal `real8` value onto the operand stack.
      """

      operands {
        literal "real8" { description "Literal value to push." }
      }
      stack_before {}
      stack_after {
        value "real8" {
          description "Literal value pushed onto the operand stack."
        }
      }
    }

    PUSHVAL0 0xC2 "Push Literal 0" {
      description """
      Pushes a literal 0 value onto the operand stack.
      """
      operands {}
      stack_before {}
      stack_after {
        zero "int4" { description "Literal 0 value." }
      }
    }

    PUSHVAL1 0xC3 "Push Literal 1" {
      description """
      Pushes a literal 1 value onto the operand stack.
      """
      operands {}
      stack_before {}
      stack_after {
        one "int4" { description "Literal 1 value." }
      }
    }
  }

  PUT 0xC4 "Put Characters to Stream" {
    description """
    Puts the given value to the provided `stream`.
    
    The actual number of stack arguments is based on `put_kind`, as different put items have different uses for the arguments.
    """
    operands {
      put_kind "put_kind" {
        description """
        Which kind of item to put.
        """
      }
    }

    stack_before {
      @conditional-case (operands).put_kind {
        @case (put_kind).boolean {
          value "nat4" { description "`boolean` value to put." }
        }
        @case (put_kind).char {
          value "nat1" { description "`char` value to put." }
        }
        @case (put_kind).char_n {
          value "addrint" { description "`char(N)` value to put." }
          length "nat4" {
            description """
            Byte length of the `char(N)` type.
            """
          }
        }
        @case (put_kind).enum {
          value "nat4" { description "`enum` value to put." }
        }
        @case (put_kind).int (put_kind).int_fract (put_kind).int_exp {
          value "int4" { description "`int` value to put." }
        }
        @case (put_kind).nat (put_kind).nat_fract (put_kind).nat_exp {
          value "nat4" { description "`nat` value to put." }
        }
        @case (put_kind).real (put_kind).real_fract (put_kind).real_exp {
          value "real8" { description "`real` value to put." }
        }
        @case (put_kind).string {
          value "addrint" { description "`string` value to put." }
        }
      }
      @conditional {
        @predicate (operands).put_kind "!=" (put_kind).skip

        width "int4" {
          description """
          Minimum number of characters to put.
          If less characters than the minimum are printed, the remaining count is padded to the right with spaces.
          """
        }
      }
      @conditional {
        @predicate (operands).put_kind "==" (put_kind).int_fract
        @predicate (operands).put_kind "==" (put_kind).nat_fract
        @predicate (operands).put_kind "==" (put_kind).real_fract

        fractional_width "int4" {
          description """
          Minimum number of decimal places to put.
          Contributes to the number of characters printed.
          """
        }
      }
      @conditional {
        @predicate (operands).put_kind "==" (put_kind).int_exp
        @predicate (operands).put_kind "==" (put_kind).nat_exp
        @predicate (operands).put_kind "==" (put_kind).real_exp

        exponent_width "int4" {
          description """
          Minimum number of exponential digits to put.
          Contributes to the number of characters printed.
          """
        }
      }
      @conditional {
        @predicate (operands).put_kind "==" (put_kind).enum

        variant_names "addrint" {
          description """
          Array of names of the enum variants.
          Any out-of-range values are put as the raw ordinal value.
          """
        }
      }
      stream "addrint" {
        description """
        Stream to put characters to.
        """
      }
    }
    stack_after {}
  }

  RETURN 0xCD "Return From Procedure" {
    // TODO: Description
    // TODO: Stack Effect
  }

  group "Set Location" {
    description """
    Modifies the current execution location to match the source code representation.

    Primarily used for debugging, this has no effect on the program state.
    """

    INCLINENO 0x7D "Increment Line Number" {
      description """
      Increments the line number up by 1.

      Primarily used for debugging, this has no effect on the program state.
      """
    }

    SETFILENO 0xD5 "Set File & Line Number" {
      description """
      Sets the current execution file number and line number.

      Primarily used for debugging, this has no effect on the program state.
      """
      
      operands {
        file_no "nat2" { description "File number to set location to." }
        line_no "nat2" { description "Line number to set location to." }
      }
    }

    SETLINENO 0xD6 "Set Line Number" {
      description """
      Sets the current execution line number, using the same file number.

      Primarily used for debugging, this has no effect on the program state.
      """
      
      operands {
        line_no "nat2" { description "Line number to set location to." }
      }
    }
  }
}
