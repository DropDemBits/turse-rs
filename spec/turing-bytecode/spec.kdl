// Bytecode specification for the original Turing 4.x VM
//
// Some invariants to keep in mind:
// - No address to the operand stack can ever be used for instructions,
//   they must always be uplifted into addresses in the locals area.

types {
  enum "quit_exception" size=4 {
    description "All named recoverable exceptions that can be thrown during program execution."
    repr_type "u32"

    tag_out_of_range 14 {}

    assignment_out_of_range 15 {}

    parameter_out_of_range 22 {}
    string_parameter_too_long 23 {}
    result_out_of_range 24 {}
    case_selector_out_of_range 25 {}
    function_no_result 26 {}
    string_value_too_long 35 {}

    pred_of_first 38 {}
    succ_of_last 39 {}

    uninit_value 45 {}

    integer_overflow 50 {}
    real_overflow 51 {}
    real_underflow 52 {}
  }

  scalar "int1" size=1 {
    description """
    8-bit signed integer.
    """
    repr_type "i8"
  }
  scalar "int2" size=2 {
    description """
    16-bit signed integer.
    """
    repr_type "i16"
  }
  scalar "int4" size=4 {
    description """
    32-bit signed integer.

    `0x80000000` is used as the `undefint` sentinel value in `int` to represent uninitialized `int` variables.
    `int4` values have no such sentinel values.
    """
    repr_type "i32"
  }
  scalar "nat2" size=2 {
    description """
    16-bit unsigned integer.
    """
    repr_type "u16"
  }
  scalar "nat4" size=4 {
    description """
    32-bit unsigned integer.

    `0xFFFFFFFF` is used as the `undefnat` sentinel value in `nat` to represent uninitialized `nat` variables.
    `nat4` values have no such sentinel values.
    """
    repr_type "u32"
  }
  scalar "real4" size=4 {
    description """
    binary32 floating-point number.
    """
    repr_type "f32"
  }
  scalar "real8" size=8 {
    description """
    binary64 floating-point number.
    """
    repr_type "f64"
  }
  scalar "set16" size=2 {
    description """
    Element of a large bitset, storing up to 16 elements.
    Sets larger than 4 bytes (32 elements) store the backing bitset as a separate allocation of an array of `set16`s.
    """
    repr_type "u16"
  }
  scalar "set32" size=4 {
    description """
    Compact bitset, storing up to 32 elements.
    Sets up to 4 bytes in size store the backing bitset inline with the value.
    """
    repr_type "u32"
  }
  scalar "offset" size=4 {
    description """
    Address-sized signed integer to offset an `addrint` address with.
    Always a 32-bit integer, and is always less than or equal to 2^31 - 1 and greater than or equal to -2^31.
    Allocations can never exceed the size of an offset, and are thus limited to a maximum of 2^31 - 1 bytes.

    `0xFFFFFFFF` is used as a sentinel value to represent uninitialized `addrint` variables.
    """
    repr_type "u32"
  }
  struct "relocatable_offset" size=8 {
    description """
    Relocatable address that is resolved at runtime.
    This is an entry within a relocatable patch list, with `link` pointing to the next entry in the list.
    Each distinct relocatable patch list refers to the local code unit sections (code, manifest, and global), as well as to other code units's sections.
    """

    link "offset" { description "Offset to the next relocatable patch entry to fixup." }
    offset "offset" { description "Offset within the section, relative to the base address." }
  }
  scalar "addrint" size=4 {
    description """
    Pointer-sized unsigned integer referring to a specific location in the execution address space.
    This is always a 32-bit integer as 64-bit execution address spaces are unsupported.
    """
    repr_type "u32"
  }
  enum "abort_reason" size=4 {
    description """
    The reason for aborting program execution
    """
    repr_type "u32"

    assert 1 {
      description "For conditional `assert` statements."
      message "Assert condition is false"
      error_code 21
    }
    pre_invariant 2 {
      description "For conditional `pre` statements."
      message "Pre condition is false"
      error_code 16
    }
    post_invariant 3 {
      description "For conditional `post` statements."
      message "Post condition is false"
      error_code 17
    }
    for_invariant 4 {
      description "For conditional `invariant` statements in for-loops."
      message "For-loop invariant is false"
      error_code 18
    }
    loop_invariant 5 {
      description "For conditional `invariant` statements in loops."
      message "Loop invariant is false"
      error_code 19
    }
    module_invariant 6 {
      description "For conditional `invariant` statements in module initialization."
      message "Module invariant is false"
      error_code 20
    }
    class_downcast 7 {
      description "For conditional class downcast expressions."
      message "Cannot convert pointer to more specific class"
      error_code 10_000
    }
    case_out_of_range 8 {
      description "For unhandled case arms in case statements without a default label."
      message "Case selector is out of range"
      error_code 25
    }
    no_result 9 {
      description "For functions that return without producing a result."
      message "Function failed to give a result"
      error_code 26
    }
  }
  enum "put_kind" size=4 {
    description """
    Valid put items for **PUT**.
    """
    repr_type "u32"

    boolean 0 {
      description """
      Boolean item for putting `boolean` values.
      """
    }
    char 1 {
      description """
      Char item for putting `char` values.
      """
    }
    char_n 2 {
      description """
      CharN item for putting `char(N)` values.

      ## Note
      The stack argument ordering is emitted in the opposite order from original Turing, where `width` and `length` are swapped.
      This uses the ordering from the bytecode executor, which is the ultimate consumer of the bytecode anyways.
      """
    }
    enum 3 {
      description """
      Enum item for putting `enum` types.

      Points to a list of variant names.
      """
    }
    int 4 {
      description """
      Int item for putting `int` types, with only the width argument.
      """
    }
    int_fract 5 {
      description """
      Int item for putting `int` types, with the width and fractional width arguments.
      """
    }
    int_exp 6 {
      description """
      Int item for putting `int` types, with the width, fractional width, and exponent width arguments.
      """
    }
    // note: some of these nat ones crash the intepreter?
    nat 7 {
      description """
      Nat item for putting `nat` types, with only the width argument.
      """
    }
    nat_fract 8 {
      description """
      Nat item for putting `nat` types, with the width and fractional width arguments.
      """
    }
    nat_exp 9 {
      description """
      Nat item for putting `nat` types, with the width, fractional width, and exponent width arguments.
      """
    }
    real 10 {
      description """
      Real item for putting `real` types, with only the width argument.
      """
    }
    real_fract 11 {
      description """
      Real item for putting `real` types, with the width and fractional width arguments.
      """
    }
    real_exp 12 {
      description """
      Real item for putting `real` types, with the width, fractional width, and exponent width arguments.
      """
    }
    string 13 {
      description """
      String item for putting `string` types.
      """
    }
    skip 14 {
      description """
      Skip item, only putting a newline.
      """
    }
  }
  enum "get_kind" size=4 {
    description """
    Valid get items for **GET**.
    """
    repr_type "u32"

    skip 14
  }
  enum "std_stream_kind" size=4 {
    description """
    Which stream to get the handle for in [**SETSTDSTREAM**].

    [**SETSTDSTREAM**](Opcode::SETSTDSTREAM)
    """
    repr_type "u32"

    get 1 {
      description """
      Stream handle for a `get`, which uses the standard in stream.
      """
      default_handle -2
    }
    put 2 {
      description """
      Stream handle for a `put`, which uses the standard out stream.
      """
      default_handle -1
    }
  }
  enum "stream_kind" size=4 {
    description """
    How to prepare the stream handle for the specified stream operation.
    """
    repr_type "u32"

    default 0 {
      description "Default stream operation, which is assumed to be a `put` operation."
    }
    get 1 {
      description "Prepare stream for a `get` operation."
    }
    put 2 {
      description "Prepare stream for a `put` operation."
    }
    read 3 {
      description "Prepare stream for a `read` operation."
    }
    write 4 {
      description "Prepare stream for a `write` operation."
    }
  }
  enum "check_kind" size=4 {
    description """
    Which kind of check is being performed in a [**CHKRANGE**].

    [**CHKRANGE**]: Opcode::CHKRANGE
    """
    repr_type "u32"

    assign 0 {
      description "Range check as part of an assignment."
    }
    any_char 1 {
      description "Negative or zero char(*) length."
    }
    chr 2 {
      description "Value passed to `chr` is not in `[0,255]`."
    }
    int_overflow 3 {
      description "After an arithmetic operation."
    }
    range_assign 4 {
      description "Range check as part of an assignemt into a range."
    }
    loop_step 5 {
      description "Computation of a for-loop step."
    }
    pred 6 {
      description "Asserting that `pred` isn't applied on the first element of a sequence."
    }
    succ 7 {
      description  "Asserting that `succ` isn't applied on the last element of a sequence."
    }
    tag_value 8 {
      description "Asserting that a value is a valid tag for a given union." 
    }
    value_param 9 {
      description "Range check as part of range parameter passing."
    }
  }
}

exceptions {
  ExecutionError "@text" {
    description """
    An unrecoverable fatal runtime error. Contains a message on more information about the error.
    """
  }
  Quit "quit_exception" {
    description """
    A recoverable runtime error. Code becomes the value passed into a `handler` block, if present. 
    """
  }
}

instructions {
  group "Abort Program" {
    description """
    Aborts program execution for a specific reason.

    The specific abort reason depends on the `abort_kind`, which is always provided
    as an operand. The instruction is invalid if `abort_kind` is not one of the
    expected abort types.
    """

    ABORT 0x00 "Abort" {
      description """
      Always aborts program execution.
      """
      operands {
        abort_kind "abort_reason" {
          description """
          What is the reason for aborting
          """
        }
      }
    }

    ABORTCOND 0x01 "Abort If Condition is False" {
      description """
      Conditionally aborts program execution based on `will_abort`.
      """
      operands {
        abort_kind "abort_reason" {
          description """
          What is the reason for aborting
          """
        }
      }
      stack_before {
        condition_holds "int4" {
          description """
          If the condition to assert holds, otherwise aborts program execution (i.e. `condition_holds` is 0).
          """
        }
      }
      stack_after {
        empty
      }
    }
  }

  group "Add Numbers" {
    description "Performs addition on two numbers."

    ADDINT 0x04 "Add Integers" {
      description "Adds as `int` values `lhs` and `rhs`, producing `out`."
      operands {}
      stack_before {
        lhs "int4" { description "Left-hand side of operation." }
        rhs "int4" { description "Right-hand side of operation." }
      }
      stack_after {
        out "int4" { description "Result of operation." }
      }
      Quit (quit_code).integer_overflow {
        description """
        When the computed value is greater than can what be represented by `out`.
        """
      }
    }
    
    ADDINTNAT 0x05 "Add Integer with Natural" {
      description "Adds `lhs` (as an `int` value) and `rhs` (as a `nat` value), producing `out`."
      operands {}
      stack_before {
        lhs "int4" { description "Left-hand side of operation." }
        rhs "nat4" { description "Right-hand side of operation." }
      }
      stack_after {
        out "int4" { description "Result of operation." }
      }
      Quit (quit_code).integer_overflow {
        description """
        When the computed value is greater than can what be represented by `out`.
        """
      }
    }
    
    ADDNAT 0x06 "Add Naturals" {
      description "Adds as `nat` values `lhs` and `rhs`, producing `out`."
      operands {}
      stack_before {
        lhs "nat4" { description "Left-hand side of operation." }
        rhs "nat4" { description "Right-hand side of operation." }
      }
      stack_after {
        out "nat4" { description "Result of operation." }
      }
      Quit (quit_code).integer_overflow {
        description """
        When the computed value is greater than can what be represented by `out`.
        """
      }
    }
    
    ADDNATINT 0x07 "Add Natural with Integer" {
      description "Adds `lhs` (as a `nat` value) and `rhs` (as an `int` value), producing `out`."
      operands {}
      stack_before {
        lhs "nat4" { description "Left-hand side of operation." }
        rhs "int4" { description "Right-hand side of operation." }
      }
      stack_after {
        out "nat4" { description "Result of operation." }
      }
      Quit (quit_code).integer_overflow {
        description """
        When the computed value is greater than can what be represented by `out`.
        """
      }
    }
    
    ADDREAL 0x08 "Add Reals" {
      description "Adds as `real` values `lhs` and `rhs`, producing `out`."
      operands {}
      stack_before {
        lhs "real8" { description "Left-hand side of operation." }
        rhs "real8" { description "Right-hand side of operation." }
      }
      stack_after {
        out "real8" { description "Result of operation." }
      }
      Quit (quit_code).real_overflow {
        description """
        When the computed value is greater than can what be represented by `out`.
        """
      }
    }
  }

  AND 0x0F "Bitwise And" {
    description """
    Applies a bitwise logical and operation between `lhs` and `rhs`, producing `out`.
    """
    operands {}
    stack_before {
      lhs "int4" { description "Left-hand side of operation." }
      rhs "int4" { description "Right-hand side of operation." }
    }
    stack_after {
      out "int4" { description "Result of operation." }
    }
  }

  group "Assign Value" {
    description """
    Stores `value` at the provided `dest` address.
    Individual assignment instructions may have different initialized value requirements.

    The *INV variants swap the stack operand order to match post-computing the destination address after the value to store.
    """

    ASNADDR 0x11 "Assign Address Value" {
      description """
      Stores a `value` as an `addrint` value at the provided `dest` address.
      """

      operands {}
      stack_before {
        value "addrint" { description "Value to store." }
        dest "addrint" { description "Address to store value at." }
      }
      stack_after {}
    }

    ASNADDRINV 0x12 "Assign Address Value (Inverted)" {
      description """
      Stores a `value` as an `addrint` value at the provided `dest` address.

      Stack operand order corresponds to post-computing the `dest` address.
      """

      operands {}
      stack_before {
        dest "addrint" { description "Address to store value at." }
        value "addrint" { description "Value to store." }
      }
      stack_after {}
    }

    ASNINT 0x13 "Assign Integer Value" {
      description """
      Stores a `value` as an `int` value at the provided `dest` address.
      Asserts that `value` is not `undefint` (`0x8000_0000`).
      """

      operands {}
      stack_before {
        value "int4" { description "Value to store." }
        dest "addrint" { description "Address to store value at." }
      }
      stack_after {}
      exceptions {
        Quit (quit_exception).uninit_value {
          description """
          When `value` is `undefint` (`0x8000_0000`).
          """
        }
      }
    }

    ASNINTINV 0x14 "Assign Integer Value (Inverted)" {
      description """
      Stores a `value` as an `int` value at the provided `dest` address.
      Asserts that `value` is not `undefint` (`0x8000_0000`).

      Stack operand order corresponds to post-computing the `dest` address.
      """

      operands {}
      stack_before {
        dest "addrint" { description "Address to store value at." }
        value "int4" { description "Value to store." }
      }
      stack_after {}
      exceptions {
        Quit (quit_exception).uninit_value {
          description """
          When `value` is `undefint` (`0x8000_0000`).
          """
        }
      }
    }

    ASNINT1 0x15 "Assign Int1 Value" {
      description """
      Stores a `value` as an `int1` value at the provided `dest` address.
      Asserts that `value` is representable as an `int1` (i.e. it is within the range `[-128..127]`).
      """

      operands {}
      stack_before {
        value "int4" { description "Value to store." }
        dest "addrint" { description "Address to store value at." }
      }
      stack_after {}
      exceptions {
        Quit (quit_exception).assignment_out_of_range {
          description """
          When `value` is outside of the range of `[-128..127]`.
          """
        }
      }
    }

    ASNINT1INV 0x16 "Assign Int1 Value (Inverted)" {
      description """
      Stores a `value` as an `int1` value at the provided `dest` address.
      Asserts that `value` is representable as an `int1` (i.e. it is within the range `[-128..127]`).

      Stack operand order corresponds to post-computing the `dest` address.
      """

      operands {}
      stack_before {
        dest "addrint" { description "Address to store value at." }
        value "int4" { description "Value to store." }
      }
      stack_after {}
      exceptions {
        Quit (quit_exception).assignment_out_of_range {
          description """
          When `value` is outside of the range of `[-128..127]`.
          """
        }
      }
    }

    ASNINT2 0x17 "Assign Int2 Value" {
      description """
      Stores a `value` as an `int2` value at the provided `dest` address.
      Asserts that `value` is representable as an `int2` (i.e. it is within the range `[-32768..32767]`).
      """

      operands {}
      stack_before {
        value "int4" { description "Value to store." }
        dest "addrint" { description "Address to store value at." }
      }
      stack_after {}
      exceptions {
        Quit (quit_exception).assignment_out_of_range {
          description """
          When `value` is outside of the range of `[-32768..32767]`.
          """
        }
      }
    }

    ASNINT2INV 0x18 "Assign Int2 Value (Inverted)" {
      description """
      Stores a `value` as an `int2` value at the provided `dest` address.
      Asserts that `value` is representable as an `int2` (i.e. it is within the range `[-32768..32767]`).

      Stack operand order corresponds to post-computing the `dest` address.
      """

      operands {}
      stack_before {
        dest "addrint" { description "Address to store value at." }
        value "int4" { description "Value to store." }
      }
      stack_after {}
      exceptions {
        Quit (quit_exception).assignment_out_of_range {
          description """
          When `value` is outside of the range of `[-32768..32767]`.
          """
        }
      }
    }

    ASNINT4 0x19 "Assign Int4 Value" {
      description """
      Stores a `value` as an `int4` value at the provided `dest` address.
      Unlike [**ASNINT**], this does not perform uninit checking.

      [**ASNINT**]: Opcode::ASNINT
      """

      operands {}
      stack_before {
        value "int4" { description "Value to store." }
        dest "addrint" { description "Address to store value at." }
      }
      stack_after {}
    }

    ASNINT4INV 0x1A "Assign Int4 Value (Inverted)" {
      description """
      Stores a `value` as an `int4` value at the provided `dest` address.
      Unlike [**ASNINTINV**], this does not perform uninit checking.

      Stack operand order corresponds to post-computing the `dest` address.

      [**ASNINTINV**]: Opcode::ASNINTINV
      """

      operands {}
      stack_before {
        dest "addrint" { description "address to store value at." }
        value "int4" { description "Value to store." }
      }
      stack_after {}
    }

    ASNNAT 0x1B "Assign Natural Value" {
      description """
      Stores a `value` as a `nat` value at the provided `dest` address.
      Asserts that `value` is not `undefnat` (`0xFFFF_FFFF`).
      """

      operands {}
      stack_before {
        value "nat4" { description "Value to store." }
        dest "addrint" { description "Address to store value at." }
      }
      stack_after {}
      exceptions {
        Quit (quit_exception).uninit_value {
          description """
          When `value` is `undefnat` (`0xFFFF_FFFF`).
          """
        }
      }
    }

    ASNNATINV 0x1C "Assign Natural Value (Inverted)" {
      description """
      Stores a `value` as an `int` value at the provided `dest` address.
      Asserts that `value` is not `undefnat` (`0xFFFF_FFFF`).

      Stack operand order corresponds to post-computing the `dest` address.
      """

      operands {}
      stack_before {
        dest "addrint" { description "Address to store value at." }
        value "nat4" { description "Value to store." }
      }
      stack_after {}
      exceptions {
        Quit (quit_exception).uninit_value {
          description """
          When `value` is `undefnat` (`0xFFFF_FFFF`).
          """
        }
      }
    }

    ASNNAT1 0x1D "Assign Nat1 Value" {
      description """
      Stores a `value` as a `nat1` value at the provided `dest` address.
      Asserts that `value` is representable as a `nat1` (i.e. it is within the range `[0..255]`).
      """

      operands {}
      stack_before {
        value "nat4" { description "Value to store." }
        dest "addrint" { description "Address to store value at." }
      }
      stack_after {}
      exceptions {
        Quit (quit_exception).assignment_out_of_range {
          description """
          When `value` is outside of the range of `[0..255]`.
          """
        }
      }
    }

    ASNNAT1INV 0x1E "Assign Nat1 Value (Inverted)" {
      description """
      Stores a `value` as a `nat1` value at the provided `dest` address.
      Asserts that `value` is representable as a `nat1` (i.e. it is within the range `[0..255]`).

      Stack operand order corresponds to post-computing the `dest` address.
      """

      operands {}
      stack_before {
        dest "addrint" { description "Address to store value at." }
        value "nat4" { description "Value to store." }
      }
      stack_after {}
      exceptions {
        Quit (quit_exception).assignment_out_of_range {
          description """
          When `value` is outside of the range of `[0..255]`.
          """
        }
      }
    }

    ASNNAT2 0x1F "Assign Int2 Value" {
      description """
      Stores a `value` as a `nat2` value at the provided `dest` address.
      Asserts that `value` is representable as a `nat2` (i.e. it is within the range `[0..65535]`).
      """

      operands {}
      stack_before {
        value "nat4" { description "Value to store." }
        dest "addrint" { description "Address to store value at." }
      }
      stack_after {}
      exceptions {
        Quit (quit_exception).assignment_out_of_range {
          description """
          When `value` is outside of the range of `[-32768..32767]`.
          """
        }
      }
    }

    ASNNAT2INV 0x20 "Assign Int2 Value (Inverted)" {
      description """
      Stores a `value` as an `nat2` value at the provided `dest` address.
      Asserts that `value` is representable as an `nat2` (i.e. it is within the range `[0..65535]`).

      Stack operand order corresponds to post-computing the `dest` address.
      """

      operands {}
      stack_before {
        dest "addrint" { description "Address to store value at." }
        value "nat4" { description "Value to store." }
      }
      stack_after {}
      exceptions {
        Quit (quit_exception).assignment_out_of_range {
          description """
          When `value` is outside of the range of `[0..65535]`.
          """
        }
      }
    }

    ASNNAT4 0x21 "Assign Nat4 Value" {
      description """
      Stores a `value` as a `nat4` value at the provided `dest` address.
      Unlike [**ASNNAT**], this does not perform uninit checking.

      [**ASNNAT**]: Opcode::ASNNAT
      """

      operands {}
      stack_before {
        value "nat4" { description "Value to store." }
        dest "addrint" { description "Address to store value at." }
      }
      stack_after {}
    }

    ASNNAT4INV 0x22 "Assign Nat4 Value (Inverted)" {
      description """
      Stores a `value` as an `nat4` value at the provided `dest` address.
      Unlike [**ASNNATINV**], this does not perform uninit checking.

      Stack operand order corresponds to post-computing the `dest` address.

      [**ASNNATINV**]: Opcode::ASNNATINV
      """

      operands {}
      stack_before {
        dest "addrint" { description "address to store value at." }
        value "nat4" { description "Value to store." }
      }
      stack_after {}
    }

    ASNNONSCALAR 0x23 "Assign Non-Scalar Value" {
      description """
      Copies `length` bytes from `src` to `dest`.
      """

      operands {
        length "nat4" { description "Number of bytes to copy." }
      }
      stack_before {
        src "addrint" { description "Address to copy bytes from." }
        dest "addrint" { description "Address to store bytes to." }
      }
      stack_after {}
    }

    ASNNONSCALARINV 0x24 "Assign Non-Scalar Value (Inverted)" {
      description """
      Copies `length` bytes from `src` to `dest`.

      Stack operand order corresponds to post-computing the `dest` address.
      """

      operands {
        length "nat4" { description "Number of bytes to copy." }
      }
      stack_before {
        dest "addrint" { description "Address to store bytes to." }
        src "addrint" { description "Address to copy bytes from." }
      }
      stack_after {}
    }

    ASNPTR 0x25 "Assign Checked Pointer Value" {
      description """
      Copies the address stored in pointer descriptor information from `src` to `dest`'s pointer descriptor.
      If `src` does not point to a `nil` (`0x0`) address, additional metadata is copied to `dest` from the pointed-to heap allocation (e.g. the generation cookie).
      """

      stack_before {
        src "addrint" { description "Address to copy pointer descriptor from." }
        dest "addrint" { description "Address to store pointer descriptor to." }
      }
      stack_after {}
    }

    ASNPTRINV 0x26 "Assign Checked Pointer Value (Inverted)" {
      description """
      Copies the address stored in pointer descriptor information from `src` to `dest`'s pointer descriptor.
      If `src` does not point to a `nil` (`0x0`) address, additional metadata is copied to `dest` from the pointed-to heap allocation (e.g. the generation cookie).
      """

      stack_before {
        src "addrint" { description "Address to copy pointer descriptor from." }
        dest "addrint" { description "Address to store pointer descriptor to." }
      }
      stack_after {}
    }
    
    ASNREAL 0x27 "Assign Real Value" {
      description """
      Stores a `value` as a `real` value at the provided `dest` address.
      Does not perform uninit checking.
      """

      operands {}
      stack_before {
        value "real8" { description "Value to store." }
        dest "addrint" { description "Address to store value at." }
      }
      stack_after {}
    }

    ASNREALINV 0x28 "Assign Real Value (Inverted)" {
      description """
      Stores a `value` as a `real` value at the provided `dest` address.
      Does not perform uninit checking.

      Stack operand order corresponds to post-computing the `dest` address.
      """

      operands {}
      stack_before {
        dest "addrint" { description "Address to store value at." }
        value "real8" { description "Value to store." }
      }
      stack_after {}
    }

    ASNREAL4 0x29 "Assign Real4 Value" {
      description """
      Stores a `value` as a `real4` value at the provided `dest` address.
      Applies a narrowing cast to `real8` to convert the value into the equivalent `real4` representation.
      """

      operands {}
      stack_before {
        value "real8" { description "Value to store." }
        dest "addrint" { description "Address to store value at." }
      }
      stack_after {}
    }

    ASNREAL4INV 0x2A "Assign Real4 Value (Inverted)" {
      description """
      Stores a `value` as a `real4` value at the provided `dest` address.
      Applies a narrowing cast to `real8` to convert the value into the equivalent `real4` representation.

      Stack operand order corresponds to post-computing the `dest` address.
      """

      operands {}
      stack_before {
        dest "addrint" { description "Address to store value at." }
        value "real8" { description "Value to store." }
      }
      stack_after {}
    }

    ASNREAL8 0x2B "Assign Real8 Value" {
      description """
      Stores a `value` as a `real8` value at the provided `dest` address.
      Does not perform uninit checking.
      """

      operands {}
      stack_before {
        value "real8" { description "Value to store." }
        dest "addrint" { description "Address to store value at." }
      }
      stack_after {}
    }
    
    ASNREAL8INV 0x2C "Assign Real8 Value (Inverted)" {
      description """
      Stores a `value` as a `real8` value at the provided `dest` address.
      Does not perform uninit checking.

      Stack operand order corresponds to post-computing the `dest` address.
      """

      operands {}
      stack_before {
        dest "addrint" { description "Address to store value at." }
        value "real8" { description "Value to store." }
      }
      stack_after {}
    }

    ASNSTR 0x2D "Assign String Value" {
      description """
      Copies up to `max_length` string bytes from `src` to `dest`.
      Asserts that the string byte length of `src` is less than or equal to `max_length`.
      Does not perform uninit checking.
      """

      stack_before {
        max_length "nat4" { description "Maximum string bytes that can be stored in `dest`." }
        src "addrint" { description "Address to copy string bytes from." }
        dest "addrint" { description "Address to store string bytes to." }
      }
      stack_after {}
      exceptions {
        Quit (quit_exception).string_value_too_long {
          description """
          When the string byte length of `src` is greater than `max_length`.
          """
        }
      }
    }

    ASNSTRINV 0x2E "Assign String Value (Inverted)" {
      description """
      Copies up to `max_length` string bytes from `src` to `dest`.
      Asserts that the string byte length of `src` is less than or equal to `max_length`.
      Does not perform uninit checking.

      Stack operand order corresponds to post-computing the `dest` address.
      """

      stack_before {
        max_length "nat4" { description "Maximum string bytes that can be stored in `dest`." }
        dest "addrint" { description "Address to store string bytes to." }
        src "addrint" { description "Address to copy string bytes from." }
      }
      stack_after {}
      exceptions {
        Quit (quit_exception).string_value_too_long {
          description """
          When the string byte length of `src` is greater than `max_length`.
          """
        }
      }
    }
  }

  CALL 0x32 "Call Procedure" {
    description """
    Changes execution to follow the procedure at the provided call address.
    Standard call ABI (that is, the call ABI of Turing/OpenTuring) requires that the call address be pushed before all of the operands.
    """

    operands {
      address_offset "offset" { description "Offset to the call address in the stack." }
    }
    stack_before {}
    stack_after {
      return_addr "addrint" { description "Return address." }
    }
    exceptions {
      Quit (quit_exception).uninit_value {
        description "When the call address is `undefaddr` (`0xFFFF_FFFF`)."
      }
      ExecutionError "Deferred subroutine has not been resolved" {
        description "When the call address is `nil` (`0x0`)."
      }
    }
  }

  CASE 0x35 "Case Of" {
    description """
    Jumps to a specific branch depending on `selector`.
    `descriptor` points to a case descriptor describing the case bounds, default branch offset, and per-entry branch.
    Succinctly, it is of the following layout:

    | Type     | Name           |
    |----------|----------------|
    | `int4`   | lower_bound    |
    | `int4`   | upper_bound    | 
    | `offset` | default_branch |
    | `offset` | arm_0          |
    | `offset` | arm_1          |
    | ...      | ...            |
    | `offset` | arm_n          |

    Note that the case descriptor cannot have more than 1000 arm offsets when targeting Turing/OpenTuring interpreters.

    All offsets are relative to the address of the `descriptor` operand.
    """

    operands {
      descriptor "offset" {
        description """
        Offset to the case descriptor table describing the jump targets
        """
      }
    }
    stack_before {
      selector "int4" { description "Selects which case target entry to use." }
    }
    stack_after {}
  }

  group "Check Invariants" {
    description """
    Checks if any of a variety of runtime invariants are held.
    This forms the basis of the dynamically-checked portion of the excution runtime.
    """

    CHKRANGE 0x3E "Check Value in Range" {
      description """
      Asserts that the value at `stack_offset` is within the range `[min..max]` (inclusive range).     

      Raises an exception dependent on `check_type` if the value is outside of the range.
      """

      operands {
        stack_offset "offset" { description "Offset to the value to check within the operand stack" }
        min "int4" { description "Minimum bound of the accepted value range." }
        max "int4" { description "Maximum bound of the accepted value range." }
        check_type "check_kind" { description "What the value range check is asserting." }
      }
      stack_before {
        value "int4" {
          description "Value to check."
          computed_offset { (operands).stack_offset }
        }
      }
      stack_after {
        value "int4" {
          description "Value that was checked."
          computed_offset { (operands).stack_offset }
          preserves (stack_before).value
        }
      }
      exceptions {
        Quit (quit_code).assignment_out_of_range {
          description """
          Raised as the assertion when `check_type` is [CheckKind::Assign].

          [CheckKind::Assign]: CheckKind::Assign
          """
        }
        ExecutionError "Size of dynamic char(n) is less than 1" {
          description """
          Raised as the assertion when `check_type` is [CheckKind::AnyChar].

          [CheckKind::AnyChar]: CheckKind::AnyChar
          """
        }
        ExecutionError "Value passed to 'chr' is < 0 or > 255" {
          description """
          Raised as the assertion when `check_type` is [CheckKind::Chr].

          [CheckKind::Chr]: CheckKind::Chr
          """
        }
        Quit (quit_code).integer_overflow {
          description """
          Raised as the assertion when `check_type` is [CheckKind::IntOverflow].

          [CheckKind::IntOverflow]: CheckKind::IntOverflow
          """
        }
        Quit (quit_code).result_out_of_range {
          description """
          Raised as the assertion when `check_type` is [CheckKind::RangeAssign].

          [CheckKind::RangeAssign]: CheckKind::RangeAssign
          """
        }
        ExecutionError "Zero or negative for loop step" {
          description """
          Raised as the assertion when `check_type` is [CheckKind::LoopStep].

          [CheckKind::LoopStep]: CheckKind::LoopStep
          """
        }
        Quit (quit_code).pred_of_first {
          description """
          Raised as the assertion when `check_type` is [CheckKind::Pred].

          [CheckKind::Pred]: CheckKind::Pred
          """
        }
        Quit (quit_code).succ_of_last {
          description """
          Raised as the assertion when `check_type` is [CheckKind::Succ].

          [CheckKind::Succ]: CheckKind::Succ
          """
        }
        Quit (quit_code).tag_out_of_range {
          description """
          Raised as the assertion when `check_type` is [CheckKind::TagValue].

          [CheckKind::TagValue]: CheckKind::TagValue
          """
        }
        Quit (quit_code).parameter_out_of_range {
          description """
          Raised as the assertion when `check_type` is [CheckKind::ValueParam].

          [CheckKind::ValueParam]: CheckKind::ValueParam
          """
        }
      }
    }
  }

  group "Compare Equal" {
    description """
    Tests if `lhs` is equal to `rhs`, putting the compare result in `compare`.
    """

    EQADDR 0x4E "Compare Equal Addresses" {
      description """
      Tests as `addrint` values if `lhs` and `rhs` are equal `addrint` values.
      """
      operands {}
      stack_before {
        lhs "addrint" { description "Left-hand side of comparison." }
        rhs "addrint" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if values are equal, 0 otherwise." }
      }
    }

    EQCHARN 0x4F "Compare Equal Char(N)" {
      description """
      Tests as `char(N)` values if `lhs` and `rhs` are equal.
      Performs a byte-by-byte comparison.
      """
      operands {
        length "nat4" {
          description """
          Byte length of the `char(N)` type.
          """
        }
      }
      stack_before {
        lhs "addrint" { description "Left-hand side of comparison." }
        rhs "addrint" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if values are equal, 0 otherwise." }
      }
    }

    EQINT 0x50 "Compare Equal Integers" {
      description """
      Tests as `int` values if `lhs` and `rhs` are equal.
      """
      operands {}
      stack_before {
        lhs "int4" { description "Left-hand side of comparison." }
        rhs "int4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if values are equal, 0 otherwise." }
      }
    }

    EQINTNAT 0x51 "Compare Equal Integer with Natural" {
      description """
      Tests if `lhs` (as an `int` value) and `rhs` (as a `nat` value) are equal values.
      If `rhs` is greater than `maxint` (`0x7FFFFFFF`), the comparison is always false.
      """
      operands {}
      stack_before {
        lhs "int4" { description "Left-hand side of comparison." }
        rhs "nat4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if values are equal, 0 otherwise." }
      }
    }

    EQNAT 0x52 "Compare Equal Nats" {
      description """
      Tests as `nat` values if `lhs` and `rhs` are equal.
      """
      operands {}
      stack_before {
        lhs "nat4" { description "Left-hand side of comparison." }
        rhs "nat4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if values are equal, 0 otherwise." }
      }
    }

    EQREAL 0x53 "Compare Equal Reals" {
      description """
      Tests as `real` values if `lhs` and `rhs` are equal.
      """
      operands {}
      stack_before {
        lhs "real8" { description "Left-hand side of comparison." }
        rhs "real8" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if values are equal, 0 otherwise." }
      }
    }

    EQSET 0x54 "Compare Equal Sets" {
      description """
      Tests as `set` values if `lhs` and `rhs` are equal.
      Performs a byte-by-byte comparison.

      `set_length` determines the size of both sets, as well as determining the set representation.
      Sets up to 4 bytes in size are stored in the compact format (as a `set32`), while sets larger than 4 bytes are stored as an indirect array of `set16`s.
      """
      operands {
        set_length "nat4" {
          description """
          Length of the set, in bytes.
          """
        }
      }
      stack_before {
        @conditional {
          @predicate (operands).set_length "<=" 4

          lhs "set32" { description "Left-hand side of comparison." }
          rhs "set32" { description "Right-hand side of comparison." }
        }
        @conditional {
          @predicate "otherwise"

          lhs "addrint" { description "Left-hand side of comparison." }
          rhs "addrint" { description "Right-hand side of comparison." }
        }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if values are equal, 0 otherwise." }
      }
    }

    EQSTR 0x55 "Compare Equal Strings" {
      description """
      Tests as `string` values if `lhs` and `rhs` are equal.
      Performs a byte-by-byte comparison.
      """
      operands {}
      stack_before {
        lhs "addrint" { description "Left-hand side of comparison." }
        rhs "addrint" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if values are equal, 0 otherwise." }
      }
    }
  }

  group "Fetch Value from Address" {
    description """
    Fetches a value from the specified `addr`.
    Individual fetch instructions may have different initialized value requirements.
    """

    FETCHADDR 0x59 "Fetch Address Value" {
      description """
      Fetches an `addrint` value from `addr`.
      Asserts that the loaded value is not `undefaddr` (`0xFFFF_FFFF`).
      """
      operands {}
      stack_before {
        addr "addrint" { description "Address of the value to load." }
      }
      stack_after {
        value "addrint" { description "Value loaded from `addr`" }
      }
      exceptions {
        Quit (quit_exception).uninit_value {
          description """
          When `value` is `undefaddr` (`0xFFFF_FFFF`).
          """
        }
      }
    }

    FETCHBOOL 0x5A "Fetch Boolean Value" {
      description """
      Fetches a `boolean` value from `addr`, performing a 1-byte load.
      Asserts that the loaded value is not `undefbool` (`0xFF`).
      """
      operands {}
      stack_before {
        addr "addrint" { description "Address of the value to load." }
      }
      stack_after {
        value "int4" { description "Value loaded from `addr`" }
      }
      exceptions {
        Quit (quit_exception).uninit_value {
          description """
          When `value` is `uninitaddr` (`0xFFFF_FFFF`).
          """
        }
      }
    }

    FETCHINT 0x5B "Fetch Integer Value" {
      description """
      Fetches an `int` value from `addr`, performing a 4-byte load.
      Asserts that the loaded value is not `undefint` (`0x8000_0000`).
      """
      operands {}
      stack_before {
        addr "addrint" { description "Address of the value to load." }
      }
      stack_after {
        value "int4" { description "Value loaded from `addr`" }
      }
      exceptions {
        Quit (quit_exception).uninit_value {
          description """
          When `value` is `undefint` (`0x8000_0000`).
          """
        }
      }
    }

    FETCHINT1 0x5C "Fetch Int1 Value" {
      description """
      Fetches an `int1` value from `addr`, performing a 1-byte load.
      Coerces the loaded `value` into an `int4` value.
      """
      operands {}
      stack_before {
        addr "addrint" { description "Address of the value to load." }
      }
      stack_after {
        value "int4" { description "Value loaded from `addr`" }
      }
    }

    FETCHINT2 0x5D "Fetch Int2 Value" {
      description """
      Fetches an `int2` value from `addr`, performing a 2-byte load.
      Coerces the loaded `value` into an `int4` value.
      """
      operands {}
      stack_before {
        addr "addrint" { description "Address of the value to load." }
      }
      stack_after {
        value "int4" { description "Value loaded from `addr`" }
      }
    }

    FETCHINT4 0x5E "Fetch Int4 Value" {
      description """
      Fetches an `int4` value from `addr`, performing a 4-byte load.
      Unlike [**FETCHINT**], this does not perform uninit checking.

      [**FETCHINT**]: Opcode::FETCHINT
      """
      operands {}
      stack_before {
        addr "addrint" { description "Address of the value to load." }
      }
      stack_after {
        value "int4" { description "Value loaded from `addr`" }
      }
    }

    FETCHNAT 0x5F "Fetch Natural Value" {
      description """
      Fetches a `nat` value from `addr`, performing a 4-byte load.
      Asserts that the loaded value is not `undefnat` (`0xFFFF_FFFF`).
      """
      operands {}
      stack_before {
        addr "addrint" { description "Address of the value to load." }
      }
      stack_after {
        value "nat4" { description "Value loaded from `addr`" }
      }
      exceptions {
        Quit (quit_exception).uninit_value {
          description """
          When `value` is `undefnat` (`0xFFFF_FFFF`).
          """
        }
      }
    }

    FETCHNAT1 0x60 "Fetch Nat1 Value" {
      description """
      Fetches a `nat1` value from `addr`, performing a 1-byte load.
      Coerces the loaded `value` into a `nat4` value.
      """
      operands {}
      stack_before {
        addr "addrint" { description "Address of the value to load." }
      }
      stack_after {
        value "nat4" { description "Value loaded from `addr`" }
      }
    }

    FETCHNAT2 0x61 "Fetch Nat2 Value" {
      description """
      Fetches a `nat2` value from `addr`, performing a 2-byte load.
      Coerces the loaded `value` into a `nat4` value.
      """
      operands {}
      stack_before {
        addr "addrint" { description "Address of the value to load." }
      }
      stack_after {
        value "nat4" { description "Value loaded from `addr`" }
      }
    }
    
    FETCHNAT4 0x62 "Fetch Nat4 Value" {
      description """
      Fetches a `nat4` value from `addr`, performing a 4-byte load.
      Unlike [**FETCHNAT**], this does not perform uninit checking.

      [**FETCHNAT**]: Opcode::FETCHNAT
      """
      operands {}
      stack_before {
        addr "addrint" { description "Address of the value to load." }
      }
      stack_after {
        value "nat4" { description "Value loaded from `addr`" }
      }
    }

    FETCHPTR 0x63 "Fetch Checked Pointer Value" {
      description """
      Fetches an `addrint` value from `addr`, performing a 4-byte load.
      Asserts that the loaded value is not `undefaddr` (`0xFFFF_FFFF`), and that the checked pointer's generation cookie matches the pointed-to allocation's generation cookie.
      """
      operands {}
      stack_before {
        addr "addrint" { description "Address of the value to load." }
      }
      stack_after {
        value "addrint" { description "Value loaded from `addr`" }
      }
      exceptions {
        Quit (quit_exception).uninit_value {
          description """
          When `value` is `undefaddr` (`0xFFFF_FFFF`).
          """
        }

        ExecutionError "Reference to previously freed pointer" {
          description """
          When the checked pointer and the pointed-to allocation's generation cookies do not match.
          Indicates a likely use-after-free scenario.
          """
        }
      }
    }

    FETCHREAL 0x64 "Fetch Real Value" {
      description """
      Fetches a `real` value from `addr`, performing an 8-byte load.
      Asserts that the loaded value is not `undefreal` (`0x8000_0000_8000_0000`).
      """
      operands {}
      stack_before {
        addr "addrint" { description "Address of the value to load." }
      }
      stack_after {
        value "real8" { description "Value loaded from `addr`" }
      }
      exceptions {
        Quit (quit_exception).uninit_value {
          description """
          When `value` is `undefreal` (`0x8000_0000_8000_0000`).
          """
        }
      }
    }

    FETCHREAL4 0x65 "Fetch Real4 Value" {
      description """
      Fetches a `real4` value from `addr`, performing a 4-byte load.
      Coerces the loaded `value` into a `real8` value.
      """
      operands {}
      stack_before {
        addr "addrint" { description "Address of the value to load." }
      }
      stack_after {
        value "real8" { description "Value loaded from `addr`" }
      }
    }

    FETCHREAL8 0x66 "Fetch Real8 Value" {
      description """
      Fetches a `real8` value from `addr`, performing an 8-byte load.
      Unlike [**FETCHREAL**], this does not perform uninit checking.

      [**FETCHREAL**]: Opcode::FETCHREAL
      """
      operands {}
      stack_before {
        addr "addrint" { description "Address of the value to load." }
      }
      stack_after {
        value "real8" { description "Value loaded from `addr`" }
      }
    }

    FETCHSET 0x67 "Fetch Compact Set Value" {
      description """
      Fetches a compact set value from `addr`, performing a `set_length`-byte load.

      Asserts that the loaded value is not:

      - `undefset8` (`0x80`) when `set_length` is 1.
      - `undefset16` (`0x8000`) when `set_length` is 2.
      - `undefset32` (`0x8000_000`) when `set_length` is 4.

      Coerces the loaded `value` into a `set32` value.
      """
      operands {
        set_length "nat4" {
          description """
          Length of the set, in bytes.
          """
        }
      }
      stack_before {
        addr "addrint" { description "Address of the value to load." }
      }
      stack_after {
        value "set32" { description "Value loaded from `addr`" }
      }
      exceptions {
        Quit (quit_exception).uninit_value {
          description """
          When `value` is the corresponding `undefsetX` value.
          """
        }
      }
    }

    FETCHSTR 0x68 "Fetch String Value" {
      description """
      Asserts that the string at `addr` is an initialized string, i.e. the first byte is not the end-of-string marker (`0x80`).
      """
      operands {}
      stack_before {
        addr "addrint" { description "Address of the string to check." }
      }
      stack_after {
        addr "addrint" {
          description "Address of the string data buffer."
          preserves (stack_before).addr
        }
      }
      exceptions {
        Quit (quit_exception).uninit_value {
          description """
          When the first byte of the string is `0x80`.
          """
        }
      }
    }
  }

  group "Begin and End For-loop" {
    // TODO: Group description

    FOR 0x6A "Begin For-Loop" {
      // TODO: Description
      operands {
        skip_offset "offset" { description "Offset to jump over for-loop body, in bytes." }
      }
      // TODO: Stack Operands
    }

    ENDFOR 0x4C "End For-Loop" {
      // TODO: Description
      operands {
        offset "offset" { description "Offset to jump to the start of the for-loop body, in bytes." }
      }
      // TODO: Stack Operands
    }
  }

  group "Compare Greater Than or Equal" {
    description """
    Tests if `lhs` is greater than or equal to `rhs`, putting the compare result in `compare`.
    """

    GECHARN 0x6F "Compare Greater or Equal Char(N)" {
      description """
      Tests as `char(N)` values if `lhs` is greater than or equal to `rhs`.
      Performs a byte-by-byte comparison.
      """
      operands {
        length "nat4" {
          description """
          Byte length of the `char(N)` type.
          """
        }
      }
      stack_before {
        lhs "addrint" { description "Left-hand side of comparison." }
        rhs "addrint" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is greater than or equal to `rhs`, 0 otherwise." }
      }
    }

    GECLASS 0x70 "Compare Descendant or Same Class" {
      descriptor """
      Tests if `lhs` is a class that is a descendant of, or the same class as `rhs`.
      This navigates up the class hierarchy of `lhs` to see if `rhs` is a member of the ancestor hierarchy.

      If `lhs` is `nil` (`0x0`), the comparison is always true as `nil` is considered a descendant of all classes.
      """

      stack_before {
        lhs "addrint" { description "Left-hand side of comparison." }
        rhs "addrint" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is a descendant of, or same class as `rhs`, 0 otherwise." }
      }
    }

    GEINT 0x71 "Compare Greater or Equal Integers" {
      description """
      Tests as `int` values if `lhs` is greater than or equal to `rhs`.
      """
      operands {}
      stack_before {
        lhs "int4" { description "Left-hand side of comparison." }
        rhs "int4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is greater than or equal to `rhs`, 0 otherwise." }
      }
    }

    GEINTNAT 0x72 "Compare Greater or Equal Natural with Integer" {
      description """
      Tests if `lhs` (as an`nat` value) is greater than or equal to `rhs` (as a `nat` value).
      If `rhs` is greater than `maxint` (`0x7FFFFFFF`), the comparison is always false.
      """
      operands {}
      stack_before {
        lhs "int4" { description "Left-hand side of comparison." }
        rhs "nat4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is greater than or equal to `rhs`, 0 otherwise." }
      }
    }

    GENAT 0x73 "Compare Greater or Equal Naturals" {
      description """
      Tests as `nat` values if `lhs` is greater than or equal to `rhs`.
      """
      operands {}
      stack_before {
        lhs "nat4" { description "Left-hand side of comparison." }
        rhs "nat4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { "Result of operation. 1 if `lhs` is greater than or equal to `rhs`, 0 otherwise." }
      }
    }

    GENATINT 0x74 "Compare Greater or Equal Integer with Natural" {
      description """
      Tests if `lhs` (as a `nat` value) is greater than or equal to `rhs` (as an `int` value).
      If `lhs` is greater than `maxint` (`0x7FFFFFFF`), the comparison is always true.
      """
      operands {}
      stack_before {
        lhs "nat4" { description "Left-hand side of comparison." }
        rhs "int" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is greater than or equal to `rhs`, 0 otherwise." }
      }
    }

    GEREAL 0x75 "Compare Greater or Equal Reals" {
      description """
      Tests as `real` values if `lhs` is greater than or equal to `rhs`.
      """
      operands {}
      stack_before {
        lhs "real8" { description "Left-hand side of comparison." }
        rhs "real8" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is greater than or equal to `rhs`, 0 otherwise." }
      }
    }

    GESET 0x76 "Compare Greater or Equal Sets" {
      description """
      Tests as `set` values if `lhs` is a supeset of `rhs` (that is, all elements in `rhs` are contained in `lhs`).
      Performs a byte-by-byte comparison.

      `set_length` determines the size of both sets, as well as determining the set representation.
      Sets up to 4 bytes in size are stored in the compact format (as a `set32`), while sets larger than 4 bytes are stored as an indirect array of `set16`s.
      """
      operands {
        set_length "nat4" {
          description """
          Length of the set, in bytes.
          """
        }
      }
      stack_before {
        @conditional {
          @predicate (operands).set_length "<=" 4

          lhs "set32" { description "Left-hand side of comparison." }
          rhs "set32" { description "Right-hand side of comparison." }
        }
        @conditional {
          @predicate "otherwise"

          lhs "addrint" { description "Left-hand side of comparison." }
          rhs "addrint" { description "Right-hand side of comparison." }
        }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is greater than or equal to `rhs`, 0 otherwise." }
      }
    }

    GESTR 0x77 "Compare Greater or Equal Strings" {
      description """
      Tests as `string` values if `lhs` is greater than or equal to `rhs`.
      Performs a byte-by-byte comparison.
      """
      operands {}
      stack_before {
        lhs "addrint" { description "Left-hand side of comparison." }
        rhs "addrint" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is greater than or equal to `rhs`, 0 otherwise." }
      }
    }
  }

  GTCLASS 0x7A "Compare Descendant Class" {
    descriptor """
    Tests if `lhs` is a class that is a descendant of `rhs`.
    This navigates up the class hierarchy of `lhs` to see if `rhs` is a member of the ancestor hierarchy.

    If `lhs` is `nil` (`0x0`), the comparison is always true as `nil` is considered a descendant of all classes.
    """

    stack_before {
      lhs "addrint" { description "Left-hand side of comparison." }
      rhs "addrint" { description "Right-hand side of comparison." }
    }
    stack_after {
      compare "int4" { description "Result of operation. 1 if `lhs` is a descendant of `rhs`, 0 otherwise." }
    }
  }

  IF 0x7B "Branch If Zero" {
    description """
    Branches execution if `test` is zero (i.e. false).
    """

    operands {
      offset "offset" { description "Offset to jump forward by if `test` is zero, in bytes." }
    }
    stack_before {
      test "int4" { description "Value to test if the branch should be taken." }
    }
    stack_after {}
  }

  INCSP 0x7E "Increment Stack Pointer" {
    description """
    Increments the stack pointer by `size` bytes.
    Equivalent to repeatedly popping values off of the stack.
    """
    operands {
      size "nat4" { description "Amount of bytes to pop off the stack." }
    }
    // TODO: stack effect of computed nat1 allocation
  }

  INFIXAND 0x7F "Infix And" {
    description """
    Branches execution if `value` is zero (i.e. false), otherwise leaves `value` on the stack.
    This is equivalent to the short-circuiting infix boolean `and` operator.
    """

    operands {
      offset "offset" { description "Offset to jump forward by if `test` is zero, in bytes." }
    }
    stack_before {
      value "int4" {
        description """
        Value to test if the branch should be taken.
        """
      }
    }
    stack_after {
      value "int4" {
        description """
        Preserved value to test if the branch was not taken.
        """
        preserves-if (stack_before).value {
          "==" (stack_before).value 0
        }
      }
    }
  }

  INFIXOR 0x80 "Infix Or" {
    description """
    Branches execution if `value` is non-zero (i.e. true), otherwise leaves `value` on the stack.
    This is equivalent to the short-circuiting infix boolean `or` operator.
    """

    operands {
      offset "offset" { description "Offset to jump forward by if `test` is non-zero, in bytes." }
    }
    stack_before {
      value "int4" {
        description """
        Value to test if the branch should be taken.
        """
      }
    }
    stack_after {
      value "int4" {
        description """
        Preserved value to test if the branch was not taken.
        """
        preserves-if (stack_before).value {
          "!=" (stack_before).value 0
        }
      }
    }
  }

  group "Compare Less or Equal" {
    description """
    Tests if `lhs` is less than or equal to `rhs`, putting the compare result in `compare`.
    """

    LECHARN 0x8B "Compare Less or Equal Char(N)" {
      description """
      Tests as `char(N)` values if `lhs` is less than or equal to `rhs`.
      Performs a byte-by-byte comparison.
      """
      operands {
        length "nat4" {
          description """
          Byte length of the `char(N)` type.
          """
        }
      }
      stack_before {
        lhs "addrint" { description "Left-hand side of comparison." }
        rhs "addrint" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is less than or equal to `rhs`, 0 otherwise." }
      }
    }

    LECLASS 0x8C "Compare Ancestor or Same Class" {
      descriptor """
      Tests if `lhs` is a class that is an ancestor of, or the same class as `rhs`.
      This navigates up the class hierarchy of `lhs` to see if `rhs` is a member of the ancestor hierarchy.

      If `rhs` is `nil` (`0x0`), the comparison is always true as `nil` is considered a descendant of all classes.
      """

      stack_before {
        lhs "addrint" { description "Left-hand side of comparison." }
        rhs "addrint" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is a descendant of, or same class as `rhs`, 0 otherwise." }
      }
    }

    LEINT 0x8D "Compare Less or Equal Integers" {
      description """
      Tests as `int` values if `lhs` is less than or equal to `rhs`.
      """
      operands {}
      stack_before {
        lhs "int4" { description "Left-hand side of comparison." }
        rhs "int4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is less than or equal to `rhs`, 0 otherwise." }
      }
    }

    LEINTNAT 0x8E "Compare Less or Equal Natural with Integer" {
      description """
      Tests if `lhs` (as an `int` value) is less than or equal to `rhs` (as a `nat` value).
      If `rhs` is greater than `maxint` (`0x7FFFFFFF`), the comparison is always true.
      """
      operands {}
      stack_before {
        lhs "int4" { description "Left-hand side of comparison." }
        rhs "nat4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is less than or equal to `rhs`, 0 otherwise." }
      }
    }

    LENAT 0x8F "Compare Less or Equal Naturals" {
      description """
      Tests as `nat` values if `lhs` is less than or equal to `rhs`.
      """
      operands {}
      stack_before {
        lhs "nat4" { description "Left-hand side of comparison." }
        rhs "nat4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is less than or equal to `rhs`, 0 otherwise." }
      }
    }

    LENATINT 0x90 "Compare Less or Equal Integer with Natural" {
      description """
      Tests if `lhs` (as a `nat` value) is less than or equal to `rhs` (as an `int` value).
      If `lhs` is greater than `maxint` (`0x7FFFFFFF`), the comparison is always false.
      """
      operands {}
      stack_before {
        lhs "nat4" { description "Left-hand side of comparison." }
        rhs "int4" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is less than or equal to `rhs`, 0 otherwise." }
      }
    }

    LEREAL 0x91 "Compare Less or Equal Reals" {
      description """
      Tests as `real` values if `lhs` is less than or equal to `rhs`.
      """
      operands {}
      stack_before {
        lhs "real8" { description "Left-hand side of comparison." }
        rhs "real8" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is less than or equal to `rhs`, 0 otherwise." }
      }
    }

    LESET 0x92 "Compare Less or Equal Sets" {
      description """
      Tests as `set` values if `lhs` is a subset of `rhs` (that is, all elements in `lhs` are contained in `rhs`).
      Performs a byte-by-byte comparison.

      `set_length` determines the size of both sets, as well as determining the set representation.
      Sets up to 4 bytes in size are stored in the compact format (as a `set32`), while sets larger than 4 bytes are stored as an indirect array of `set16`s.
      """
      operands {
        set_length "nat4" {
          description """
          Length of the set, in bytes.
          """
        }
      }
      stack_before {
        @conditional {
          @predicate (operands).set_length "<=" 4

          lhs "set32" { description "Left-hand side of comparison." }
          rhs "set32" { description "Right-hand side of comparison." }
        }
        @conditional {
          @predicate "otherwise"

          lhs "addrint" { description "Left-hand side of comparison." }
          rhs "addrint" { description "Right-hand side of comparison." }
        }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is less than or equal to `rhs`, 0 otherwise." }
      }
    }

    LESTR 0x93 "Compare Less or Equal Strings" {
      description """
      Tests as `string` values if `lhs` is less than or equal to `rhs`.
      Performs a byte-by-byte comparison.
      """
      operands {}
      stack_before {
        lhs "addrint" { description "Left-hand side of comparison." }
        rhs "addrint" { description "Right-hand side of comparison." }
      }
      stack_after {
        compare "int4" { description "Result of operation. 1 if `lhs` is less than or equal to `rhs`, 0 otherwise." }
      }
    }
  }

  group "Jump" {
    description """
    Changes program execution forwards or backwards. 
    """
    
    JUMP 0x89 "Jump Forward" {
      description """
      Advances program counter forwards by `offset` bytes.
      Offset is relative to the address of the offset operand.
      """

      operands {
        offset "offset" { description "Offset to jump forward by, in bytes." }
      }
    }

    JUMPB 0x8A "Jump Backward" {
      description """
      Retreats program counter backwards by `offset` bytes.
      Offset is relative to the address of the offset operand.
      """
      
      operands {
        offset "offset" { description "Offset to jump backwards by, in bytes." }
      }
    }
  }

  group "Locate Address" {
    LOCATELOCAL 0x96 "Locate Local Slot" {
      description """
      Locates the address of a local in the current call frame.
      Offset is computed relative to the start of the local area.
      """

      operands {
        offset "offset" { description "Offset in the locals area." }
      }
      stack_before {}
      stack_after {
        address "addrint" { description "Address of the computed local slot." }
      }
    }

    LOCATEPARM 0x97 "Locate Parameter" {
      description """
      Locates the address of a passed-in parameter in the current call frame.
      Offset is computed relative to the start of the call frame.
      """

      operands {
        offset "offset" { description "Offset from the start of the call frame." }
      }
      stack_before {}
      stack_after {
        address "addrint" { description "Address of the computed parameter slot." }
      }
    }

    LOCATETEMP 0x98 "Locate Temporary Slot" {
      description """
      Locates the address of a temporary in the current call frame.
      Offset is computed relative to the start of the temporaries area.

      As the temporaries area is located after the locals area in the call frame, the size of the call frame must also be known.
      """

      operands {
        frame_size "nat4" { description "Size of the call frame." }
        offset "offset" { description "Offset in the temporary area." }
      }
      stack_before {}
      stack_after {
        address "addrint" { description "Address of the computed temporary slot." }
      }
    }
  }

  LTCLASS 0x99 "Compare Ancestor Class" {
    descriptor """
    Tests if `lhs` is a class that is an ancestor of `rhs`.
    This navigates up the class hierarchy of `lhs` to see if `rhs` is a member of the ancestor hierarchy.

    If `rhs` is `nil` (`0x0`), the comparison is always true as `nil` is considered a descendant of all classes.
    """

    stack_before {
      lhs "addrint" { description "Left-hand side of comparison." }
      rhs "addrint" { description "Right-hand side of comparison." }
    }
    stack_after {
      compare "int4" { description "Result of operation. 1 if `lhs` is a descendant of `rhs`, 0 otherwise." }
    }
  }

  group "Negate Number" {
    NEGINT 0xAC "Negate Integer" {
      description """
      Flips the sign of `value` as an `int`, as if it were multiplied by -1.

      (throws) If `value` is less than `minint` (`-0x7FFFFFFF`) as there are no equivalent positive values.
      """

      operands {}
      stack_before {
        value "int4" { description "Value to apply operation on." }
      }
      stack_after {
        out "int4" { description "Result of operation." }
      }
    }

    NEGREAL 0xAD "Negate Real" {
      description """
      Flips the sign of `value` as a `real`, as if it were multiplied by -1.

      (throws) If `value` is less than `minint` (`-0x7FFFFFFF`) as there are no equivalent positive values.
      """

      operands {}
      stack_before {
        value "real8" { description "Value to apply operation on." }
      }
      stack_after {
        out "real8" { description "Result of operation." }
      }
    }
  }

  NOT 0xB2 "Boolean Not" {
    description """
    Applies a boolean not operation on `value`, by only flipping the first bit.
    For a bitwise logical not, a [**XOR**] instruction with a 0xFFFFFFFF constant should be used. 

    [**XOR**]: Opcode::XOR
    """

    operands {}
    stack_before {
      value "int4" { description "The boolean value to invert." }
    }
    stack_before {
      out "int4" { description "The inverted boolean value." }
    }
  }

  OR 0xB6 "Bitwise Or" {
    description """
    Applies a bitwise logical or operation between `lhs` and `rhs`, producing `out`.
    """
    operands {}
    stack_before {
      lhs "int4" { description "Left-hand side of operation." }
      rhs "int4" { description "Right-hand side of operation." }
    }
    stack_after {
      out "int4" { description "Result of operation." }
    }
  }

  PROC 0xBA "Begin Procedure" {
    // TODO: Description
    operands {
      frame_size "nat4" {
        description "Size of the call frame to allocate for locals and temporaries."
      }
    }
    // TODO: Stack effect (needs computed for frame size)
  }

  group "Push Value Onto Stack" {
    PUSHADDR 0xBB "Push Address" {
      description """
      Pushes an absolute address. The address will not be relocated.
      """

      operands {
        addr "addrint" { description "Absolute address to refer to."}
      }
      stack_before {}
      stack_after {
        addr "addrint" { description "Absolute address." }
      }
    }

    PUSHADDR1 0xBC "Push Relocatable Address" {
      description """
      Pushes a relocatable address with a runtime-determined base address.

      This may be relative to the base address of the local or external code unit section (code, manifest, or global).
      """
      operands {
        offset "relocatable_offset" { description "Runtime-resolved offset within a section." }
      }
      stack_before {}
      stack_after {
        addr "addrint" { description "Computed offset and base address." }
      }
    }

    PUSHCOPY 0xBD "Push Copy of Value" {
      description """
      Pushes a copy of the top value on the operand stack.

      Will only copy `nat4` sized or smaller values.
      """

      operands {}
      stack_before {
        value "nat4" { description "Value to copy." }
      }
      stack_after {
        value "nat4" {
          description "Original value to copy."
          preserves (stack_before).value
        }
        copy "nat4" {
          description "Copied value."
        }
      }
    }

    PUSHINT 0xBE "Push Literal Integer Value" {
      description """
      Pushes a literal `int` value onto the operand stack.
      """

      operands {
        literal "int4" { description "Literal value to push." }
      }
      stack_before {}
      stack_after {
        value "int4" {
          description "Literal value pushed onto the operand stack."
        }
      }
    }

    PUSHINT1 0xBF "Push Literal Int1 Value" {
      description """
      Pushes a literal `int1` value onto the operand stack.
      """

      operands {
        literal "int1" { description "Literal value to push." }
      }
      stack_before {}
      stack_after {
        value "int1" {
          description "Literal value pushed onto the operand stack."
        }
      }
    }

    PUSHINT2 0xC0 "Push Literal Int2 Value" {
      description """
      Pushes a literal `int2` value onto the operand stack.
      """

      operands {
        literal "int2" { description "Literal value to push." }
      }
      stack_before {}
      stack_after {
        value "int2" {
          description "Literal value pushed onto the operand stack."
        }
      }
    }

    PUSHREAL 0xC1 "Push Literal Real Value" {
      description """
      Pushes a literal `real8` value onto the operand stack.
      """

      operands {
        literal "real8" { description "Literal value to push." }
      }
      stack_before {}
      stack_after {
        value "real8" {
          description "Literal value pushed onto the operand stack."
        }
      }
    }

    PUSHVAL0 0xC2 "Push Literal 0" {
      description """
      Pushes a literal 0 value onto the operand stack.
      """
      operands {}
      stack_before {}
      stack_after {
        zero "int4" { description "Literal 0 value." }
      }
    }

    PUSHVAL1 0xC3 "Push Literal 1" {
      description """
      Pushes a literal 1 value onto the operand stack.
      """
      operands {}
      stack_before {}
      stack_after {
        one "int4" { description "Literal 1 value." }
      }
    }
  }

  PUT 0xC4 "Put Characters to Stream" {
    description """
    Puts the given value to the provided `stream`.
    
    The actual number of stack arguments is based on `put_kind`, as different put items have different uses for the arguments.
    """
    operands {
      put_kind "put_kind" {
        description """
        Which kind of item to put.
        """
      }
    }

    stack_before {
      @conditional-case (operands).put_kind {
        @case (put_kind).boolean {
          value "nat4" { description "`boolean` value to put." }
        }
        @case (put_kind).char {
          value "nat1" { description "`char` value to put." }
        }
        @case (put_kind).char_n {
          value "addrint" { description "`char(N)` value to put." }
          length "nat4" {
            description """
            Byte length of the `char(N)` type.
            """
          }
        }
        @case (put_kind).enum {
          value "nat4" { description "`enum` value to put." }
        }
        @case (put_kind).int (put_kind).int_fract (put_kind).int_exp {
          value "int4" { description "`int` value to put." }
        }
        @case (put_kind).nat (put_kind).nat_fract (put_kind).nat_exp {
          value "nat4" { description "`nat` value to put." }
        }
        @case (put_kind).real (put_kind).real_fract (put_kind).real_exp {
          value "real8" { description "`real` value to put." }
        }
        @case (put_kind).string {
          value "addrint" { description "`string` value to put." }
        }
      }
      @conditional {
        @predicate (operands).put_kind "!=" (put_kind).skip

        width "int4" {
          description """
          Minimum number of characters to put.
          If less characters than the minimum are printed, the remaining count is padded to the right with spaces.
          """
        }
      }
      @conditional {
        @predicate (operands).put_kind "==" (put_kind).int_fract
        @predicate (operands).put_kind "==" (put_kind).nat_fract
        @predicate (operands).put_kind "==" (put_kind).real_fract

        fractional_width "int4" {
          description """
          Minimum number of decimal places to put.
          Contributes to the number of characters printed.
          """
        }
      }
      @conditional {
        @predicate (operands).put_kind "==" (put_kind).int_exp
        @predicate (operands).put_kind "==" (put_kind).nat_exp
        @predicate (operands).put_kind "==" (put_kind).real_exp

        exponent_width "int4" {
          description """
          Minimum number of exponential digits to put.
          Contributes to the number of characters printed.
          """
        }
      }
      @conditional {
        @predicate (operands).put_kind "==" (put_kind).enum

        variant_names "addrint" {
          description """
          Array of names of the enum variants.
          Any out-of-range values are put as the raw ordinal value.
          """
        }
      }
      stream "addrint" {
        description """
        Stream to put characters to.
        """
      }
    }
    stack_after {}
  }

  RETURN 0xCD "Return From Procedure" {
    // TODO: Description
    // TODO: Stack Effect
  }

  group "Set Location" {
    description """
    Modifies the current execution location to match the source code representation.

    Primarily used for debugging, this has no effect on the program state.
    """

    INCLINENO 0x7D "Increment Line Number" {
      description """
      Increments the line number up by 1.

      Primarily used for debugging, this has no effect on the program state.
      """
    }

    SETFILENO 0xD5 "Set File & Line Number" {
      description """
      Sets the current execution file number and line number.

      Primarily used for debugging, this has no effect on the program state.
      """
      
      operands {
        file_no "nat2" { description "File number to set location to." }
        line_no "nat2" { description "Line number to set location to." }
      }
    }

    SETLINENO 0xD6 "Set Line Number" {
      description """
      Sets the current execution line number, using the same file number.

      Primarily used for debugging, this has no effect on the program state.
      """
      
      operands {
        line_no "nat2" { description "Line number to set location to." }
      }
    }
  }

  SETSTDSTREAM 0xD8 "Set Standard I/O Stream" {
    description """
    Retrieves the standard I/O handle for `kind` and stores it in `dest`.
    Depending on the I/O redirection settings, this may differ from the standard stream handle numbers.
    """

    operands {
      kind "std_stream_kind" { description "Which standard stream handle to retrieve." }
    }
    stack_before {
      dest "addrint" { description "Address to store the stream handle to." }
    }
    stack_after {}
  }

  SETSTREAM 0xD9 "Set Stream Information" {
    description """
    Prepares for future stream operations on `stream_handle`, setting up the `stream_status` and opening the stream if necessary.
    `kind` indicates what stream operation to open the stream for if the stream is not open yet.

    Asserts that `stream_handle` is less than or equal to `maxstreamno` and greater than or equal to `stdoutstream` (`-2`).
    """

    operands {
      kind "stream_kind" { description "Which operation to prepare the stream for." }
    }
    stack_before {
      save_status "addrint" { description "Address to save the new stream status address to." }
      save_handle "addrint" { description "Address to save the new stream handle to." }
      stream_status "addrint" { description "Where to store the status of future stream operations." }
      stream_handle "int4" { description "Which stream to perform future operations on." }
    }
    stack_after {}
    exceptions {
      ExecutionError "I/O attempted on illegal stream number {stream_handle}" {
        description "When `stream_handle` is outside the range of `[-2..maxstreamno]`."
      }
    }
  }

  SHL 0xDA "Arithmetic Shift Left" {
    description """
    Applies an arithmetic left bit-shift on `value`.
    Asserts that the computed value is representable as a `nat4`.
    """

    operands {}
    stack_before {
      shift "nat4" { description "How many bits to shift by." }
      value "nat4" { description "The value to apply the bit-shift to." }
    }
    stack_after {
      out "nat4" { description "The result of the bit-shift operation." }
    }
    exceptions {
      Quit (quit_code).integer_overflow {
        description """
        When the computed value is greater than can what be represented by a `nat4`.
        """
      }
    }
  }

  SHR 0xDB "Arithmetic Shift Right" {
    description """
    Applies an arithmetic right bit-shift on `value` by copying empty positions with the sign bit.
    """

    operands {}
    stack_before {
      shift "nat4" { description "How many bits to shift by." }
      value "nat4" { description "The value to apply the bit-shift to." }
    }
    stack_after {
      out "nat4" { description "The result of the bit-shift operation." }
    }
  }

  group "Mark as Uninitialized" {
    description """
    Marks an address as containing an uninitialized value, either storing a single value or following an uninitialization pattern.
    """

    UNINITADDR 0xF0 "Mark Uninitialized Address" {
      description """
      Stores `undefaddr` (`0xFFFF_FFFF`) to `dest`.
      """

      operands {}
      stack_before {
        dest "addrint" { description "Address to mark as having an uninitialized value." }
      }
      stack_after {}
    }

    UNINITBOOLEAN 0xF1 "Mark Uninitialized Boolean" {
      description """
      Stores `undefbool` (`0xFF`) to `dest`.
      """

      operands {}
      stack_before {
        dest "addrint" { description "Address to mark as having an uninitialized value." }
      }
      stack_after {}
    }

    UNINITINT 0xF2 "Mark Uninitialized Integer" {
      description """
      Stores `undefint` (`0x8000_0000`) to `dest`.
      """

      operands {}
      stack_before {
        dest "addrint" { description "Address to mark as having an uninitialized value." }
      }
      stack_after {}
    }

    UNINITNAT 0xF3 "Mark Uninitialized Natural" {
      description """
      Stores `undefnat` (`0xFFFF_FFFF`) to `dest`.
      """

      operands {}
      stack_before {
        dest "addrint" { description "Address to mark as having an uninitialized value." }
      }
      stack_after {}
    }

    UNINITREAL 0xF4 "Mark Uninitialized Real" {
      description """
      Stores `undefreal` (`0x8000_0000_8000_0000`) to `dest`.
      """

      operands {}
      stack_before {
        dest "addrint" { description "Address to mark as having an uninitialized value." }
      }
      stack_after {}
    }

    UNINITSTR 0xF5 "Mark Uninitialized String" {
      description """
      Stores an end-of-string marker (`0x80`) followed by a nul terminator byte (`0x00`) to `dest`.
      """

      operands {}
      stack_before {
        dest "addrint" { description "Address to mark as having an uninitialized value." }
      }
      stack_after {}
    }
  }

  XOR 0xFA "Bitwise Exclusive-Or" {
    description """
    Applies a bitwise logical xor operation between `lhs` and `rhs`, producing `out`.
    """
    operands {}
    stack_before {
      lhs "int4" { description "Left-hand side of operation." }
      rhs "int4" { description "Right-hand side of operation." }
    }
    stack_after {
      out "int4" { description "Result of operation." }
    }
  }
}
